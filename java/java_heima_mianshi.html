<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java面试总结 | Zenbu Space</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/assets/img/favicon.ico">
    <meta name="description" content="属于Zenbu的个人博客，持续记录对技术的讲解和梳理学习的知识">
    
    <link rel="preload" href="/blog/assets/css/0.styles.c2eac126.css" as="style"><link rel="preload" href="/blog/assets/js/app.5cf145b8.js" as="script"><link rel="preload" href="/blog/assets/js/2.a59f6ee1.js" as="script"><link rel="preload" href="/blog/assets/js/4.c20dd059.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ebdacc7e.js"><link rel="prefetch" href="/blog/assets/js/11.5b92bcb6.js"><link rel="prefetch" href="/blog/assets/js/12.3775846d.js"><link rel="prefetch" href="/blog/assets/js/13.0d25ebcd.js"><link rel="prefetch" href="/blog/assets/js/14.ae1aacae.js"><link rel="prefetch" href="/blog/assets/js/15.96f13d95.js"><link rel="prefetch" href="/blog/assets/js/16.9d928f8a.js"><link rel="prefetch" href="/blog/assets/js/17.53415660.js"><link rel="prefetch" href="/blog/assets/js/18.a4bc894e.js"><link rel="prefetch" href="/blog/assets/js/19.8d81ed15.js"><link rel="prefetch" href="/blog/assets/js/20.26f2bfb0.js"><link rel="prefetch" href="/blog/assets/js/21.4502dce7.js"><link rel="prefetch" href="/blog/assets/js/22.8f5a25ef.js"><link rel="prefetch" href="/blog/assets/js/23.7c5c9567.js"><link rel="prefetch" href="/blog/assets/js/24.ca2c3768.js"><link rel="prefetch" href="/blog/assets/js/25.6d8bbb42.js"><link rel="prefetch" href="/blog/assets/js/26.83039fbb.js"><link rel="prefetch" href="/blog/assets/js/27.adf92751.js"><link rel="prefetch" href="/blog/assets/js/28.f2a024b0.js"><link rel="prefetch" href="/blog/assets/js/29.b3926ca2.js"><link rel="prefetch" href="/blog/assets/js/3.1fcfa166.js"><link rel="prefetch" href="/blog/assets/js/30.40311e72.js"><link rel="prefetch" href="/blog/assets/js/31.c606d6bc.js"><link rel="prefetch" href="/blog/assets/js/32.1a2b64e2.js"><link rel="prefetch" href="/blog/assets/js/33.c9197e3a.js"><link rel="prefetch" href="/blog/assets/js/34.cdcb1225.js"><link rel="prefetch" href="/blog/assets/js/35.dcf7bf36.js"><link rel="prefetch" href="/blog/assets/js/36.ee20ca71.js"><link rel="prefetch" href="/blog/assets/js/37.adc3728f.js"><link rel="prefetch" href="/blog/assets/js/38.b1a60eb1.js"><link rel="prefetch" href="/blog/assets/js/39.254937f1.js"><link rel="prefetch" href="/blog/assets/js/40.78db51cb.js"><link rel="prefetch" href="/blog/assets/js/41.d9ca5bc7.js"><link rel="prefetch" href="/blog/assets/js/42.ea0a803d.js"><link rel="prefetch" href="/blog/assets/js/43.73b011a9.js"><link rel="prefetch" href="/blog/assets/js/44.bb4d0a8e.js"><link rel="prefetch" href="/blog/assets/js/45.5b12916f.js"><link rel="prefetch" href="/blog/assets/js/46.da1586e9.js"><link rel="prefetch" href="/blog/assets/js/47.d9436699.js"><link rel="prefetch" href="/blog/assets/js/48.0e0875ef.js"><link rel="prefetch" href="/blog/assets/js/49.f37da9a2.js"><link rel="prefetch" href="/blog/assets/js/5.923729f1.js"><link rel="prefetch" href="/blog/assets/js/50.e6807bb8.js"><link rel="prefetch" href="/blog/assets/js/51.279356c7.js"><link rel="prefetch" href="/blog/assets/js/52.42f15bb0.js"><link rel="prefetch" href="/blog/assets/js/53.c2ee570b.js"><link rel="prefetch" href="/blog/assets/js/54.b05f4789.js"><link rel="prefetch" href="/blog/assets/js/55.0dd0fd5d.js"><link rel="prefetch" href="/blog/assets/js/56.b21f6abc.js"><link rel="prefetch" href="/blog/assets/js/57.7a560703.js"><link rel="prefetch" href="/blog/assets/js/58.729a904b.js"><link rel="prefetch" href="/blog/assets/js/59.9fb40538.js"><link rel="prefetch" href="/blog/assets/js/6.fae665ef.js"><link rel="prefetch" href="/blog/assets/js/60.27a63915.js"><link rel="prefetch" href="/blog/assets/js/61.e309bf9f.js"><link rel="prefetch" href="/blog/assets/js/62.efb2b7de.js"><link rel="prefetch" href="/blog/assets/js/63.6a6d79d0.js"><link rel="prefetch" href="/blog/assets/js/64.12006acb.js"><link rel="prefetch" href="/blog/assets/js/65.8a1adaa8.js"><link rel="prefetch" href="/blog/assets/js/66.3c866e11.js"><link rel="prefetch" href="/blog/assets/js/7.39c6f4a0.js"><link rel="prefetch" href="/blog/assets/js/8.8113b657.js"><link rel="prefetch" href="/blog/assets/js/9.138ddabb.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.c2eac126.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container tech-page"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/img/logo.png" alt="Zenbu Space" class="logo"> <span class="site-name can-hide">Zenbu Space</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  🏠Home
</a></div><div class="nav-item"><a href="/blog/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><a href="/blog/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/blog/java/" class="nav-link router-link-active">
  ☕Java
</a></div><div class="nav-item"><a href="/blog/algorithm/leetcode100top.html" class="nav-link">
  💫算法
</a></div><div class="nav-item"><a href="/blog/mark_md.html" class="nav-link">
  Markdown
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Liberary Menu" class="dropdown-title"><span class="title">Liberary</span> <span class="arrow down"></span></button> <button type="button" aria-label="Liberary Menu" class="mobile-dropdown-title"><span class="title">Liberary</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/proletarian/" class="nav-link">
  阅读
</a></li><li class="dropdown-item"><!----> <a href="/blog/resource.html" class="nav-link">
  资源
</a></li></ul></div></div> <a href="https://github.com/DishuZ/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  🏠Home
</a></div><div class="nav-item"><a href="/blog/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><a href="/blog/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/blog/java/" class="nav-link router-link-active">
  ☕Java
</a></div><div class="nav-item"><a href="/blog/algorithm/leetcode100top.html" class="nav-link">
  💫算法
</a></div><div class="nav-item"><a href="/blog/mark_md.html" class="nav-link">
  Markdown
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Liberary Menu" class="dropdown-title"><span class="title">Liberary</span> <span class="arrow down"></span></button> <button type="button" aria-label="Liberary Menu" class="mobile-dropdown-title"><span class="title">Liberary</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/proletarian/" class="nav-link">
  阅读
</a></li><li class="dropdown-item"><!----> <a href="/blog/resource.html" class="nav-link">
  资源
</a></li></ul></div></div> <a href="https://github.com/DishuZ/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java技术文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/" aria-current="page" class="sidebar-link">🎮 基础知识</a></li><li><a href="/blog/java/basic/java_basic_x_annotation.html" class="sidebar-link">🎯 注解</a></li><li><a href="/blog/java/basic/java_basic_x_proxy.html" class="sidebar-link">👫 代理模式</a></li><li><a href="/blog/java/java_use.html" class="sidebar-link">⚙ 即用工具箱</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/java_collections.html" class="sidebar-link">📦 Collections</a></li><li><a href="/blog/java/jvm/java_jvm_classload.html" class="sidebar-link">类加载过程详解</a></li><li><a href="/blog/java/jvm/java_jvm_jmm.html" class="sidebar-link">JVM 内存模型</a></li><li><a href="/blog/java/jvm/java_jvm_struct.html" class="sidebar-link">JVM 内存结构</a></li><li><a href="/blog/java/java_qa.html" class="sidebar-link">💬 面经</a></li><li><a href="/blog/java/java_heima_mianshi.html" aria-current="page" class="active sidebar-link">Java面试总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/java_heima_mianshi.html#资源" class="sidebar-link">资源</a></li><li class="sidebar-sub-header"><a href="/blog/java/java_heima_mianshi.html#redis篇" class="sidebar-link">Redis篇</a></li><li class="sidebar-sub-header"><a href="/blog/java/java_heima_mianshi.html#🎯java集合篇" class="sidebar-link">🎯Java集合篇</a></li><li class="sidebar-sub-header"><a href="/blog/java/java_heima_mianshi.html#并发编程篇" class="sidebar-link">并发编程篇</a></li><li class="sidebar-sub-header"><a href="/blog/java/java_heima_mianshi.html#jvm虚拟机篇" class="sidebar-link">JVM虚拟机篇</a></li><li class="sidebar-sub-header"><a href="/blog/java/java_heima_mianshi.html#框架篇" class="sidebar-link">框架篇</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java面试总结"><a href="#java面试总结" class="header-anchor">#</a> Java面试总结</h1> <p></p><div class="table-of-contents-default"><div class="toc-container-header">文章目录</div><ul><li><a href="#资源">资源</a></li><li><a href="#redis篇">Redis篇</a><ul><li><a href="#问题-我看你做的项目中-都用到了-redis-你在最近的项目中哪些场景使用了-redis-呢">问题：我看你做的项目中，都用到了 Redis，你在最近的项目中哪些场景使用了 Redis 呢？</a><ul><li><a href="#⚪-问题-什么是缓存穿透、击穿、雪崩-如果发生了缓存穿透、击穿、雪崩-该如何解决">⚪ 问题：什么是缓存穿透、击穿、雪崩？如果发生了缓存穿透、击穿、雪崩，该如何解决？</a><ul><li><a href="#⚪-❓什么是缓存穿透、击穿、雪崩">⚪ ❓什么是缓存穿透、击穿、雪崩？</a></li><li><a href="#⚪-❓怎么解决缓存穿透">⚪ ❓怎么解决缓存穿透？</a></li><li><a href="#⚪-❓怎么解决缓存击穿">⚪ ❓怎么解决缓存击穿？</a></li><li><a href="#⚪-❓怎么解决缓存雪崩">⚪ ❓怎么解决缓存雪崩？</a></li></ul></li><li><a href="#⚪-问题-redis做为缓存-mysql的数据如何与redis进行同步呢-双写一致性">⚪ 问题：Redis做为缓存，Mysql的数据如何与Redis进行同步呢？（双写一致性）</a></li><li><a href="#⚪-问题-redis做为缓存-数据的持久化是怎么做的">⚪ 问题：Redis做为缓存，数据的持久化是怎么做的？</a></li></ul></li></ul></li><li><a href="#🎯java集合篇">🎯Java集合篇</a><ul><li><a href="#list相关面试题">List相关面试题</a><ul><li><a href="#⚪-arraylist底层的实现原理❓">⚪ ArrayList底层的实现原理❓</a></li><li><a href="#⚪-arraylist的扩容机制❓">⚪ ArrayList的扩容机制❓</a></li><li><a href="#⚪-arraylist和array-数组-的区别❓">⚪ ArrayList和Array（数组）的区别❓</a></li><li><a href="#⚪-如何实现array-数组-和list之间的转换❓">⚪ 如何实现Array（数组）和List之间的转换❓</a></li><li><a href="#⚪-arraylist和linkedlist的区别❓">⚪ ArrayList和LinkedList的区别❓</a></li><li><a href="#⚪-arraydeque-与-linkedlist-的区别❓">⚪ ArrayDeque 与 LinkedList 的区别❓</a></li><li><a href="#说一说-priorityqueue">说一说 PriorityQueue</a></li></ul></li><li><a href="#hashmap相关面试题">HashMap相关面试题</a><ul><li><a href="#⚪-hashmap的put方法具体流程❓">⚪ HashMap的put方法具体流程❓</a></li><li><a href="#⚪-hashmap的寻址算法❓">⚪ HashMap的寻址算法❓</a></li><li><a href="#⚪-讲一讲hashmap的扩容机制❓">⚪ 讲一讲HashMap的扩容机制❓</a></li><li><a href="#⚪-为何hashmap的数组长度一定是2的次幂-❓">⚪ 为何HashMap的数组长度一定是2的次幂？❓</a></li><li><a href="#⚪-hashmap在jdk1-7下的多线程操作导致死循环问题❓">⚪ HashMap在JDK1.7下的多线程操作导致死循环问题❓</a></li><li><a href="#⚪-hashmap和hashset的区别❓">⚪ HashMap和HashSet的区别❓</a></li><li><a href="#⚪-hashmap为什么线程不安全❓">⚪ HashMap为什么线程不安全❓</a></li></ul></li></ul></li><li><a href="#并发编程篇">并发编程篇</a><ul><li><a href="#线程的基本知识">线程的基本知识</a><ul><li><a href="#⚪-线程和进程的区别❓">⚪ 线程和进程的区别❓</a></li><li><a href="#⚪-并行和并发的区别❓">⚪ 并行和并发的区别❓</a></li><li><a href="#⚪-创建线程的方式有哪些❓">⚪ 创建线程的方式有哪些❓</a></li><li><a href="#⚪-使用runnable和callable都可以创建线程-它们有什么区别❓">⚪ 使用Runnable和Callable都可以创建线程，它们有什么区别❓</a></li><li><a href="#⚪-在启动线程的时候-可以使用run方法吗-run-和start-有什么区别❓">⚪ 在启动线程的时候，可以使用run方法吗？run()和start()有什么区别❓</a></li><li><a href="#⚪-线程包括哪些状态-状态之间是如何变化❓">⚪ 线程包括哪些状态，状态之间是如何变化❓</a></li><li><a href="#⚪-wait-和sleep-方法的不同❓">⚪ wait()和sleep()方法的不同❓</a></li><li><a href="#⚪-如何停止一个正在运行的线程❓">⚪ 如何停止一个正在运行的线程❓</a></li></ul></li><li><a href="#线程中的并发安全">线程中的并发安全</a><ul><li><a href="#⚪-synchronized关键字的底层原理❓">⚪ synchronized关键字的底层原理❓</a></li><li><a href="#⚪-谈谈-jmm-java内存模型-❓">⚪ 谈谈 JMM（Java内存模型）❓</a></li><li><a href="#⚪-谈谈-cas-另外什么是悲观锁和乐观锁❓">⚪ 谈谈 CAS，另外什么是悲观锁和乐观锁❓</a></li><li><a href="#⚪-请谈谈你对-volatile-的理解❓">⚪ 请谈谈你对 volatile 的理解❓</a></li><li><a href="#⚪-请你说一下自己对于-aqs-原理的理解❓">⚪ 请你说一下自己对于 AQS 原理的理解❓</a></li><li><a href="#⚪-reentrantlock的实现原理❓">⚪ ReentrantLock的实现原理❓</a></li><li><a href="#⚪-synchronized和lock有什么区别❓">⚪ synchronized和Lock有什么区别❓</a></li><li><a href="#⚪-死锁产生的条件是什么❓">⚪ 死锁产生的条件是什么❓</a></li><li><a href="#⚪-如何进行死锁诊断❓">⚪ 如何进行死锁诊断❓</a></li><li><a href="#⚪-聊一下concurrenthashmap❓">⚪ 聊一下ConcurrentHashMap❓</a></li><li><a href="#⚪-导致并发程序出现问题的根本原因是什么❓">⚪ 导致并发程序出现问题的根本原因是什么❓</a></li></ul></li><li><a href="#线程池">线程池</a><ul><li><a href="#⚪-说一下线程池的核心参数-线程池的执行原理知道嘛-❓">⚪ 说一下线程池的核心参数（线程池的执行原理知道嘛）❓</a></li><li><a href="#⚪-线程池中有哪些常见的阻塞队列❓">⚪ 线程池中有哪些常见的阻塞队列❓</a></li><li><a href="#⚪-如何确定核心线程数❓">⚪ 如何确定核心线程数❓</a></li><li><a href="#⚪-线程池的种类有哪些❓">⚪ 线程池的种类有哪些❓</a></li><li><a href="#⚪-为什么不建议用executors创建线程池❓">⚪ 为什么不建议用Executors创建线程池❓</a></li></ul></li><li><a href="#使用场景">使用场景</a><ul><li><a href="#⚪-线程池使用场景-你们项目中哪里用到了线程池-❓">⚪ 线程池使用场景(你们项目中哪里用到了线程池)❓</a></li><li><a href="#⚪-如何控制某个方法允许并发访问线程的数量❓">⚪ 如何控制某个方法允许并发访问线程的数量❓</a></li><li><a href="#⚪-谈谈你对threadlocal的理解❓">⚪ 谈谈你对ThreadLocal的理解❓</a></li></ul></li></ul></li><li><a href="#jvm虚拟机篇">JVM虚拟机篇</a><ul><li><a href="#jvm组成">JVM组成</a><ul><li><a href="#⚪什么是程序计数器❓">⚪什么是程序计数器❓</a></li><li><a href="#⚪你能给我详细的介绍下堆吗❓">⚪你能给我详细的介绍下堆吗❓</a></li><li><a href="#⚪能不能介绍一下方法区❓">⚪能不能介绍一下方法区❓</a></li><li><a href="#⚪你听过直接内存吗❓">⚪你听过直接内存吗❓</a></li><li><a href="#⚪什么是虚拟机栈❓">⚪什么是虚拟机栈❓</a></li><li><a href="#⚪什么情况下会导致栈内存溢出❓">⚪什么情况下会导致栈内存溢出❓</a></li><li><a href="#⚪堆栈的区别是什么❓">⚪堆栈的区别是什么❓</a></li></ul></li><li><a href="#类加载器">类加载器</a><ul><li><a href="#⚪-什么是类加载器-类加载器有哪些❓">⚪ 什么是类加载器，类加载器有哪些❓</a></li><li><a href="#⚪-什么是双亲委派模型❓">⚪ 什么是双亲委派模型❓</a></li><li><a href="#⚪-jvm为什么采用双亲委派机制❓">⚪ JVM为什么采用双亲委派机制❓</a></li><li><a href="#⚪-说一下类装载的执行过程❓">⚪ 说一下类装载的执行过程❓</a></li></ul></li><li><a href="#垃圾回收">垃圾回收</a><ul><li><a href="#⚪-对象什么时候可以被垃圾器回收❓">⚪ 对象什么时候可以被垃圾器回收❓</a></li><li><a href="#⚪-强引用、软引用、弱引用、虚引用❓">⚪ 强引用、软引用、弱引用、虚引用❓</a></li><li><a href="#⚪-jvm-垃圾回收算法有哪些❓">⚪ JVM 垃圾回收算法有哪些❓</a></li><li><a href="#⚪-说一下jvm中的分代回收❓">⚪ 说一下JVM中的分代回收❓</a></li><li><a href="#⚪-说一下jvm有哪些垃圾回收器❓">⚪ 说一下JVM有哪些垃圾回收器❓</a></li><li><a href="#⚪-详细聊一下g1垃圾回收器❓">⚪ 详细聊一下G1垃圾回收器❓</a></li></ul></li><li><a href="#jvm-实践">JVM 实践</a><ul><li><a href="#⚪-jvm-调优的参数可以在哪里设置❓">⚪ JVM 调优的参数可以在哪里设置❓</a></li><li><a href="#⚪-用的-jvm-调优的参数都有哪些❓">⚪ 用的 JVM 调优的参数都有哪些❓</a></li><li><a href="#⚪-说一下-jvm-调优的工具❓">⚪ 说一下 JVM 调优的工具❓</a></li><li><a href="#⚪-java内存泄露的排查思路❓">⚪ Java内存泄露的排查思路❓</a></li><li><a href="#⚪-cpu飙高排查方案与思路❓">⚪ CPU飙高排查方案与思路❓</a></li></ul></li></ul></li><li><a href="#框架篇">框架篇</a></li></ul></div><p></p> <h2 id="资源"><a href="#资源" class="header-anchor">#</a> 资源</h2> <p>网盘：https://pan.baidu.com/s/1NQZDW-9_VCnEUXcXp_G-bA&amp;pwd=9987</p> <h2 id="redis篇"><a href="#redis篇" class="header-anchor">#</a> Redis篇</h2> <p>面试问题总览：</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240520001700.png" alt="黑马Redis面试问题总览" class="zoom"> <h3 id="问题-我看你做的项目中-都用到了-redis-你在最近的项目中哪些场景使用了-redis-呢"><a href="#问题-我看你做的项目中-都用到了-redis-你在最近的项目中哪些场景使用了-redis-呢" class="header-anchor">#</a> 问题：我看你做的项目中，都用到了 Redis，你在最近的项目中哪些场景使用了 Redis 呢？</h3> <p>该问题一是验证你的项目场景的真实性，二是为了作为深入发问的切入点。因此，<strong>要根据自己简历上的业务进行回答</strong>。</p> <p>使用场景及对应深入问题：</p> <table><thead><tr><th style="text-align:center;">使用场景</th> <th style="text-align:center;">深入问题</th></tr></thead> <tbody><tr><td style="text-align:center;">缓存</td> <td style="text-align:center;">缓存三兄弟 (穿透、击穿、雪崩) 、双写一致、持久化、数据过期策略，数据淘汰策略</td></tr> <tr><td style="text-align:center;">分式锁</td> <td style="text-align:center;">setnx、redisson</td></tr> <tr><td style="text-align:center;">消息队列、延迟队列</td> <td style="text-align:center;">何种数据类型</td></tr></tbody></table> <h4 id="⚪-问题-什么是缓存穿透、击穿、雪崩-如果发生了缓存穿透、击穿、雪崩-该如何解决"><a href="#⚪-问题-什么是缓存穿透、击穿、雪崩-如果发生了缓存穿透、击穿、雪崩-该如何解决" class="header-anchor">#</a> ⚪ 问题：什么是缓存穿透、击穿、雪崩？如果发生了缓存穿透、击穿、雪崩，该如何解决？</h4> <h5 id="⚪-❓什么是缓存穿透、击穿、雪崩"><a href="#⚪-❓什么是缓存穿透、击穿、雪崩" class="header-anchor">#</a> ⚪ ❓什么是缓存穿透、击穿、雪崩？</h5> <p>（1）<strong>缓存穿透</strong></p> <p>当 <strong>用户访问的数据，既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是 <strong>缓存穿透</strong> 的问题。</p> <p>（2）<strong>缓存击穿</strong></p> <p><strong>缓存中的某个热点数据过期了</strong>，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被 <strong>高并发的请求</strong> 冲垮，这就是 <strong>缓存击穿</strong> 的问题。</p> <p>（3）<strong>缓存雪崩</strong></p> <p>当 <strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong> 时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是 <strong>缓存雪崩</strong> 的问题</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240520100823.png" alt="小林Coding-缓存异常总结" class="zoom"> <h5 id="⚪-❓怎么解决缓存穿透"><a href="#⚪-❓怎么解决缓存穿透" class="header-anchor">#</a> ⚪ ❓怎么解决缓存穿透？</h5> <p>▣ 解决方案1：限制非法请求</p> <p>在 API 入口处（在访问缓存和数据库之前）判断请求参数是否合理（数据合法性校验），请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p> <p>▣ 解决方案2：缓存空值或者默认值</p> <p>可针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p> <ul><li>优点：简单</li> <li>缺点：消耗内存，可能会发生数据不一致的问题</li></ul> <p>▣ 解决方案3：布隆过滤器快速判断数据是否存在</p> <p>在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，说明数据库中不存在该数据，则直接返回，无需查询数据库。</p> <p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行。</p> <ul><li>优点：内存占用较少，没有多余 key</li> <li>缺点：实现复杂，存在误判</li></ul> <h5 id="⚪-❓怎么解决缓存击穿"><a href="#⚪-❓怎么解决缓存击穿" class="header-anchor">#</a> ⚪ ❓怎么解决缓存击穿？</h5> <p>▣ 解决方案1：互斥锁</p> <p>在缓存失效时，需要去访问数据库更新缓存。因此，通过添加互斥锁，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p> <p>▣ 解决方案2：不给热点数据设置过期时间 / 逻辑过期</p> <p>在设置缓存时，给key添加一个过期时间字段。在查询缓存数据时，判断数据的过期时间字段是否过期。</p> <p>如果过期了，开一个线程由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存，并重新设置过期时间字段。当前请求线程仍然正常返回数据，这个数据不是还最新的。</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240520104948.png" alt="缓存击穿解决方案：互斥锁&amp;逻辑过期" class="zoom"> <h5 id="⚪-❓怎么解决缓存雪崩"><a href="#⚪-❓怎么解决缓存雪崩" class="header-anchor">#</a> ⚪ ❓怎么解决缓存雪崩？</h5> <p>发生缓存雪崩有两个原因：</p> <ol><li>大量数据同时过期</li> <li>Redis 故障宕机</li></ol> <p>不同的诱因，应对的策略也会不同。</p> <p>◉ <strong>原因1：大量数据同时过期</strong></p> <p>▣ 解决方案1：均匀设置过期时间</p> <p>避免将大量的数据设置成同一个过期时间，所以在对缓存数据设置过期时间时，给这些数据的过期时间加上一个随机数，这样就保证数据不会在同一时间过期。</p> <p>▣ 解决方案2：互斥锁</p> <p>当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p> <p>实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p> <p>▣ 解决方案3：后台更新缓存 / 不给热点数据设置过期时间 / 逻辑过期</p> <p>◉ <strong>原因2：Redis 故障宕机</strong></p> <p>▣ 解决方案1：服务熔断或请求限流机制</p> <p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动 <strong>服务熔断机制</strong>，暂停业务应用对缓存服务的访问，直接返回错误，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p> <p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作，所以要审慎选择该操作。</p> <p>为了减少对业务的影响，我们可以启用 <strong>请求限流机制</strong>，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p> <p>▣ 解决方案2：构建 Redis 缓存高可靠集群</p> <p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过主从节点的方式构建 Redis 缓存高可靠集群。</p> <p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p> <h4 id="⚪-问题-redis做为缓存-mysql的数据如何与redis进行同步呢-双写一致性"><a href="#⚪-问题-redis做为缓存-mysql的数据如何与redis进行同步呢-双写一致性" class="header-anchor">#</a> ⚪ 问题：Redis做为缓存，Mysql的数据如何与Redis进行同步呢？（双写一致性）</h4> <p>简单回顾数据一致性问题：</p> <p>引入Redis缓存后，客户端请求数据时，如果能在缓存中命中数据，那就查询缓存，不用在去查询数据库，从而减轻数据库的压力，提高服务器的性能。</p> <p>但是引入了缓存，那么在数据更新时，需要同时处理Redis缓存和Mysql数据库中的数据，这其中就涉及到数据一致性的问题。</p> <p><strong>思路1</strong>：数据更新时，同时更新缓存和数据库</p> <ul><li>策略1：先更新缓存，再更新数据库</li> <li>策略2：先更新数据库，再更新缓存</li></ul> <p>这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象</p> <p><strong>如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案</strong>，因为这种策略不会出现缓存未命中的情况。同时增加一些手段来解决数据不一致的问题，这里提供两种做法：</p> <ul><li>在更新缓存前先<strong>加个分布式锁</strong>，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li> <li>在更新完缓存时，给缓存<strong>加上较短的过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</li></ul> <p><strong>思路2</strong>：写操作—数据更新时，只更新数据库，删除缓存；读操作—在数据读取时，如果缓存命中，直接返回。如果缓存未命中，则查询数据库数据，写入缓存设置超时时间。</p> <ul><li>策略1：先删除缓存，再更新数据库</li> <li>策略2：先更新数据库，再删除缓存</li></ul> <p>策略1 在「读操作+写操作」并发的时候，还是会出现缓存和数据库的数据不一致的问题。而 策略2 在原子操作下一定程度上可以保证数据一致性。</p> <p>针对策略1在「读操作+写操作」并发请求而造成缓存不一致的解决办法是「延迟双删」，伪代码如下：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 删除缓存</span>
redis.delKey<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token comment"># 更新数据库</span>
db.update<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token comment"># 睡眠</span>
Thread.sleep<span class="token punctuation">(</span>N<span class="token punctuation">)</span>
<span class="token comment"># 再删除缓存</span>
redis.delKey<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>策略2在原子操作下可以保证数据一致性，也就是说还是可能出现数据不一致的问题，怎么发生的？其实就是：在删除缓存（第二个操作）的时候失败了，导致缓存还是旧值，而数据库是最新值，造成数据库和缓存数据不一致的问题，会对敏感业务造成影响。</p> <p>有两种解决方法：</p> <ul><li>方法1：重试机制—引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。
<ul><li>如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li> <li>如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul></li></ul> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240520154503.png" alt="先更新数据库，再删除缓存—异步方案—MQ重试机制" class="zoom"> <ul><li>方法2：订阅 MySQL binlog，再操作缓存。</li></ul> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240520154813.png" alt="先更新数据库，再删除缓存—异步方案—订阅 MySQL binlog" class="zoom"> <h4 id="⚪-问题-redis做为缓存-数据的持久化是怎么做的"><a href="#⚪-问题-redis做为缓存-数据的持久化是怎么做的" class="header-anchor">#</a> ⚪ 问题：Redis做为缓存，数据的持久化是怎么做的？</h4> <h2 id="🎯java集合篇"><a href="#🎯java集合篇" class="header-anchor">#</a> 🎯Java集合篇</h2> <h3 id="list相关面试题"><a href="#list相关面试题" class="header-anchor">#</a> List相关面试题</h3> <h4 id="⚪-arraylist底层的实现原理❓"><a href="#⚪-arraylist底层的实现原理❓" class="header-anchor">#</a> ⚪ ArrayList底层的实现原理❓</h4> <h4 id="⚪-arraylist的扩容机制❓"><a href="#⚪-arraylist的扩容机制❓" class="header-anchor">#</a> ⚪ ArrayList的扩容机制❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>扩容核心方法</strong>：<code>grow(int minCapacity)</code>, 参数表示最小需要容量，是为了保证数组长度能够容纳至少 <code>minCapacity</code> 个元素</p> <p><strong>扩容机制</strong>：</p> <ul><li>在调用 <code>add(E e)</code> 或其他添加元素的方法时，内部首先会通过 <code>ensureCapacityInternal()</code> 来保证数组拥有足够空间，然后再添加元素。</li> <li><code>ensureCapacityInternal()</code> 方法内部就会判断数组是否需要扩容，若需要，就调用 <code>grow()</code> 方法。</li> <li>在 <code>grow()</code> 内部，ArrayList 每次扩容之后的容量都会变为原来的 1.5 倍左右（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>, oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</li></ul> <p><strong>扩容示例</strong>（以无参构造实例化ArrayList为例）：</p> <ul><li>无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组（<code>this.elementData = {}</code>）。</li> <li>当我们要 <code>add</code> 进第 1 个元素到 ArrayList 时，<code>elementData.length</code> 为 <code>0</code> （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 <code>minCapacity</code> 此时为 <code>10</code>。此时，<code>minCapacity - elementData.length &gt; 0</code> 成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li> <li>当 <code>add</code> 第 2 个元素时，<code>minCapacity</code> 为 <code>2</code>，此时 <code>elementData.length(容量)</code> 在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li> <li>添加第 3、4···到第 10 个元素时，依然不会执行 <code>grow</code> 方法，数组容量都为 10。</li> <li>直到添加第 11 个元素，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 <code>grow</code> 方法进行扩容，数组扩容成 15。</li></ul></div></div><h4 id="⚪-arraylist和array-数组-的区别❓"><a href="#⚪-arraylist和array-数组-的区别❓" class="header-anchor">#</a> ⚪ ArrayList和Array（数组）的区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>ArrayList 内部<strong>基于动态数组实现</strong>，比 Array（静态数组） 使用起来更加灵活。</p> <p>两者的区别可以从以下这几方面回答：</p> <ul><li><strong>扩容机制</strong>：<code>ArrayList</code> 会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li> <li><strong>泛型支持</strong>：<code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li> <li><strong>存储类型</strong>：<code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li> <li><strong>操作能力</strong>：<code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code> 等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li> <li><strong>初始化</strong>：<code>ArrayList</code>创建时不需要指定大小，而 <code>Array</code> 创建时必须指定大小。</li></ul></div></div><h4 id="⚪-如何实现array-数组-和list之间的转换❓"><a href="#⚪-如何实现array-数组-和list之间的转换❓" class="header-anchor">#</a> ⚪ 如何实现Array（数组）和List之间的转换❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）两个方法</p> <ul><li>数组转List ，使用JDK中 <code>java.util.Arrays</code> 工具类的 <code>asList</code> 方法
<ul><li>使用List的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code> 会抛出异常</li> <li>通过几种方法可以解决上条无法修改的问题，比如：
<ul><li>方法1：<code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></li> <li>方法2：使用Java8的 <code>Stream</code>（推荐）</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span>
<span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span> myList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>myArray2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>方法3：使用Java9的 <code>List.of()</code> 方法</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul></li> <li>List转数组，使用 <code>List</code> 的 <code>toArray</code> 方法。
<ul><li>无参 <code>toArray</code> 方法返回 <code>Object</code> 数组</li> <li>传入数组对象，返回该对象数组</li></ul></li></ul> <p>（2）代码示例</p> <ul><li>数组转List<div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token comment">// int数组，需要使用基本类型对应的包装类来创建数组</span>
<span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> b1 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// String数组</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bbb&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cccc&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> b2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li>List转数组<div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// LinkedList也可以</span>
b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span> b1<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;bbb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;ccc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> a2 <span class="token operator">=</span> b2<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// new String[0]就是起一个模板的作用</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ul> <p><strong>拓展问题</strong>：</p> <p>🧛🏻‍♂️ 问：用 <code>Arrays.asList</code> 将数组转 List 后，如果修改了数组内容，List 受影响吗？</p> <p>🙋🏻‍♂️ 答：Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p> <p>🧛🏻‍♂️ 问：List 用 <code>toArray</code> 转数组后，如果修改了 List 内容，数组受影响吗？</p> <p>🙋🏻‍♂️ 答：list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p></div></div><h4 id="⚪-arraylist和linkedlist的区别❓"><a href="#⚪-arraylist和linkedlist的区别❓" class="header-anchor">#</a> ⚪ ArrayList和LinkedList的区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>可以从以下几方面回答：</p> <ul><li><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li> <li><strong>底层数据结构</strong>： ArrayList 底层使用的是 <code>Object</code> 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li> <li><strong>插入和删除是否受元素位置的影响</strong>：
<ul><li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 <code>add(E e)</code> 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li> <li>LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>, <code>remove(int index)</code>）， 时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，因为需要先移动到指定位置再插入和删除。</li></ul></li> <li><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)。</li> <li><strong>内存空间占用</strong>： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul> <blockquote><p>阅读 <code>RandomAccess</code> 接口中的源码，发现其中什么都没有定义，所以其作用是标识实现这个接口的类具有随机访问功能</p></blockquote></div></div><h4 id="⚪-arraydeque-与-linkedlist-的区别❓"><a href="#⚪-arraydeque-与-linkedlist-的区别❓" class="header-anchor">#</a> ⚪ ArrayDeque 与 LinkedList 的区别❓</h4> <p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？</p> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li> <li><code>ArrayDeque</code> 不支持存储 NULL 数据，但 <code>LinkedList</code> 支持。</li> <li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li> <li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul> <p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p></div></div><h4 id="说一说-priorityqueue"><a href="#说一说-priorityqueue" class="header-anchor">#</a> 说一说 PriorityQueue</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p> <p>这里列举其相关的一些要点：</p> <ul><li><strong>底层</strong>：<code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，<strong>底层使用可变长的数组</strong>来存储数据</li> <li><strong>调整</strong>：<code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li> <li><strong>元素</strong>：<code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 NULL 和 non-comparable 的对象。</li> <li><strong>初始化</strong>：<code>PriorityQueue</code> <strong>默认是小顶堆</strong>，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li></ul> <p>注：<code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p></div></div><h3 id="hashmap相关面试题"><a href="#hashmap相关面试题" class="header-anchor">#</a> HashMap相关面试题</h3> <h4 id="⚪-hashmap的put方法具体流程❓"><a href="#⚪-hashmap的put方法具体流程❓" class="header-anchor">#</a> ⚪ HashMap的put方法具体流程❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>HashMap 的 <code>put(key, value)</code> 添加方法：</p> <ol><li>计算 <code>key</code> 的 <code>hash</code> 值（通过 <code>hash(key)</code> 计算）：
<ul><li>JDK 1.7：
<ul><li>(1) <code>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</code></li> <li>(2) <code>h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</code></li></ul></li> <li>JDK 1.8：<code>((h = key.hashCode()) ^ (h &gt;&gt;&gt; 16))</code></li></ul></li> <li>定位 <code>key</code> 存储位置 bucket（桶） 下标：<code>index = hash &amp; (table.length - 1)</code>；</li> <li>插入操作，分情况：
<ul><li>情况1 bucket 为空桶：<strong>直接插入</strong></li> <li>情况2 bucket 非空桶：快速判断第一个节点是否与插入的 <code>key</code> 相同，<strong>相同则插入</strong>，不同则继续...（JDK 1.8 要先判断是链表还是红黑树，再接着遍历）
<ul><li><code>key</code> 不存在：<strong>将键值存储到链表/红黑树尾部</strong>；（Java7 是插入到链表的最前面/头插法）</li> <li><code>key</code> 存在：遍历链表/红黑树比较 key，<strong>如果存在 key，更新 value</strong>；</li></ul></li></ul></li> <li>插入/更新元素之后，判断当前 bucket 链表是否需要升级为红黑树：链表长度大于 8 ，并且数组长度大于 64，则升级为红黑树（<code>treeifyBin</code> 方法中判断是否真的转换为红黑树）；</li> <li>扩容判断：<code>++size &gt; threshold</code> 成立，则进行扩容操作 <code>resize()</code>；（Java7 是先扩容后插入新值的，Java8 先插值再扩容）</li> <li>将执行结果返回</li></ol></div></div><h4 id="⚪-hashmap的寻址算法❓"><a href="#⚪-hashmap的寻址算法❓" class="header-anchor">#</a> ⚪ HashMap的寻址算法❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ul><li><strong>Step1</strong> / 首先，通过 <code>hash(key)</code> 得到对应 <code>key</code> 的哈希值 <code>hash</code> <ul><li><code>key</code> 为 <code>null</code> 时，<code>hash</code> 为 <code>0</code></li> <li><code>key</code> 不为 <code>null</code> 时，计算 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，即将 <code>key.hashCode()</code> 的 高16位 和 低16位 进行 异或运算，运算结果作为哈希值 <code>hash</code></li> <li><code>hash(key)</code> 相当于对原始哈希码做了扰动，使得扰动后的新哈希码 <code>hash</code> 更加均匀，减少哈希冲突</li></ul></li> <li><strong>Step2</strong> / 然后，通过 <code>hash &amp; (n - 1)</code> 计算 <code>key</code> 在哈希表（数组）中的 bucket（桶） 索引
<ul><li><code>n</code> 表示哈希表（数组）长度</li> <li>该计算代替常规的取模运算，性能更好。前提是：要求 <code>n</code> 必须是 2 的次幂</li></ul></li></ul></div></div><h4 id="⚪-讲一讲hashmap的扩容机制❓"><a href="#⚪-讲一讲hashmap的扩容机制❓" class="header-anchor">#</a> ⚪ 讲一讲HashMap的扩容机制❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>关键点</strong>：扩容入口 <code>put()</code> 、扩容函数 <code>resize()</code> 、惰性加载、容量翻倍、数据迁移</p> <p><strong>内容</strong>：</p> <p>HashMap 是惰性加载，在创建对象 <code>new HashMap&lt;&gt;()</code> 时并没有初始化数组。</p> <p>因此，在首次使用 HashMap 实例的 <code>put</code> 操作时，会调用 <code>resize()</code> 方法进行扩容：</p> <ul><li>如果是无参构造，那么初始化数组长度为16；</li> <li>如果提供了参数 <code>initialCapacity</code>，那么初始化数组长度是与 <code>initialCapacity</code> 最接近的 2 的幂次方大小（HashMap 中的 <code>tableSizeFor(initialCapacity)</code> 方法保证）；</li></ul> <p>在 <code>put</code> 操作之后，都会检查 <code>++size &gt; threshold</code> 是否成立（<code>size</code> 表示 HashMap 已存放的元素数量，<code>threshold</code> 表示容量阈值）。如果成立，表示需要扩容，数组扩大到之前容量的 2 倍 <code>newThr = oldThr &lt;&lt; 1</code>。</p> <p>在 <code>resize()</code> 中，扩容操作是创建一个新的数组，所以在扩容后需要把老数组中的数据挪动到新数组中：</p> <ul><li>如果是没有哈希冲突的节点，直接计算节点新的位置即可 <code>e.hash &amp; (newCap - 1)</code></li> <li>如果是红黑树，则走红黑树的添加</li> <li>如果是链表，则遍历链表每个节点，通过 <code>hash &amp; oldCap == 0</code> 判断节点是否需要换位置，<code>true</code> 表示留在原位置 <code>j</code>，<code>false</code> 表示移动到新位置 <code>j + oldCap</code></li></ul></div></div><h4 id="⚪-为何hashmap的数组长度一定是2的次幂-❓"><a href="#⚪-为何hashmap的数组长度一定是2的次幂-❓" class="header-anchor">#</a> ⚪ 为何HashMap的数组长度一定是2的次幂？❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li><strong>计算索引时效率更高</strong>：如果是 2 的 n 次幂，可以使用位与运算代替取模运算；</li> <li><strong>扩容时重新计算索引效率更高</strong>：扩容时，<code>newCap</code> 是 <code>oldCap</code> 的 2倍，重新计算某个 bucket <code>oldTab[j]</code> 中的链表结点的下标时，满足 <code>hash &amp; oldCap == 0</code> 的元素留在原来位置 <code>j</code>，即 <code>newTab[j]</code>，否则该元素的新位置为 <code>j+oldCap</code>，即 <code>newTab[j + oldCap]</code></li></ol></div></div><h4 id="⚪-hashmap在jdk1-7下的多线程操作导致死循环问题❓"><a href="#⚪-hashmap在jdk1-7下的多线程操作导致死循环问题❓" class="header-anchor">#</a> ⚪ HashMap在JDK1.7下的多线程操作导致死循环问题❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>JDK1.7 及之前版本的 HashMap 在多线程环境下扩容操作可能存在死循环问题，这是由于当<strong>一个桶位</strong>中有<strong>多个元素</strong>需要进行扩容时，<strong>多个线程</strong>同时对链表进行操作，<strong>头插法</strong>可能会<strong>导致链表中的节点指向错误的位置</strong>，从而<strong>形成一个环形链表</strong>，进而使得后续的查询元素操作陷入遍历死循环无法结束。</p> <p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p> <p>⚠ 注：不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在数据覆盖的问题。并发环境下，推荐使用 ConcurrentHashMap 。</p></div></div><h4 id="⚪-hashmap和hashset的区别❓"><a href="#⚪-hashmap和hashset的区别❓" class="header-anchor">#</a> ⚪ HashMap和HashSet的区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><code>HashSet</code> 里面有一个 <code>HashMap</code>（适配器模式），所以可以说：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p> <p><code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code> 是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p> <p>以下为 <code>HashMap</code> 部分源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//HashSet是对HashMap的简单包装</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
	<span class="token comment">//......</span>

	<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span><span class="token comment">//HashSet里面有一个HashMap</span>
    <span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//......</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//简单的方法转换</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//......</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></div></div><h4 id="⚪-hashmap为什么线程不安全❓"><a href="#⚪-hashmap为什么线程不安全❓" class="header-anchor">#</a> ⚪ HashMap为什么线程不安全❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>JDK1.7 及之前版本，在多线程环境下，HashMap 扩容时会造成 <strong>死循环</strong> 和 <strong>数据丢失</strong> 的问题。</p> <p><strong>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在</strong> ，这里以 JDK 1.8 为例进行介绍。</p> <p>JDK 1.8 后，在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。<strong>多个线程</strong> 对 HashMap 的 <code>put</code> 操作会导致线程不安全，具体来说<strong>会有数据覆盖的风险</strong>。</p> <p>举个例子：</p> <ul><li>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</li> <li>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</li> <li>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</li></ul> <p>还有一种情况是这两个线程同时 put 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p> <ul><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li> <li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li> <li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 <code>size</code> 的值更新为 11。</li> <li>线程 1、2 都执行了一次 put 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 HashMap 中。</li></ul></div></div><h2 id="并发编程篇"><a href="#并发编程篇" class="header-anchor">#</a> 并发编程篇</h2> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240521162913.png" alt="黑马并发面试问题总览" class="zoom"> <h3 id="线程的基本知识"><a href="#线程的基本知识" class="header-anchor">#</a> 线程的基本知识</h3> <h4 id="⚪-线程和进程的区别❓"><a href="#⚪-线程和进程的区别❓" class="header-anchor">#</a> ⚪ 线程和进程的区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）概念</p> <ul><li><strong>进程（Process）</strong> 是指计算机中正在运行的一个程序实例。<span style="color:rgb(122 116 116);">举例：你打开的微信就是一个进程。</span></li> <li><strong>线程（Thread）</strong> 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源，比如内存空间、文件句柄、网络连接等。<span style="color:rgb(122 116 116);">举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</span></li></ul> <blockquote><p>在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是线程。</p></blockquote> <p>（2）区别</p> <ul><li><strong>基本单位</strong>：进程是操作系统<strong>分配资源的基本单位</strong>；线程是<strong>程序执行（CPU调度）的基本单位</strong>；</li> <li><strong>包含关系</strong>：一个进程可以包含一个或多个线程；线程不能包含进程；</li> <li><strong>资源占有</strong>：进程拥有一个完整的资源平台（独立的内存空间和资源）；线程只独享必不可少的资源（如寄存器和栈），共享进程的内存和资源；</li> <li><strong>状态</strong>：进程和线程都具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li> <li><strong>开销</strong>：线程能减少并发执行的时间和空间开销（进程切换的成本比较大；线程切换成本比较小）；</li></ul> <p>对于“线程相比进程能减少开销”，体现在：</p> <ul><li><strong>创建开销</strong>：线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li> <li><strong>销毁开销</strong>：线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li> <li><strong>切换开销</strong>：同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li> <li><strong>交互开销</strong>：由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul></div></div><h4 id="⚪-并行和并发的区别❓"><a href="#⚪-并行和并发的区别❓" class="header-anchor">#</a> ⚪ 并行和并发的区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）概念不同</p> <ul><li><strong>并发</strong>（concurrent）：同一时间应对（dealing with）多件事情 / 两个及两个以上的作业在 <strong>同一时间段</strong> 内执行。</li> <li><strong>并行</strong>（parallel）：同一时间动手做（doing）多件事情 / 两个及两个以上的作业在 <strong>同一时刻</strong> 执行。</li></ul> <p>最关键的点是：是否是同时执行。</p> <p>（2）在多核 CPU 下</p> <ul><li>并发：多个线程轮流使用一个CPU</li> <li>并行：4个CPU核同时执行4个线程</li></ul></div></div><h4 id="⚪-创建线程的方式有哪些❓"><a href="#⚪-创建线程的方式有哪些❓" class="header-anchor">#</a> ⚪ 创建线程的方式有哪些❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>Java 中创建线程的三种标准方式</strong>：</p> <ol><li>继承 <code>Thread</code> 类，重写 <code>run()</code> 方法</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1) 继承 `Thread` 类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2) 重写 `run()` 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 创建线程对象</span>
        instance<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>实现 <code>Runnable</code> 接口，重写 <code>run()</code> 方法</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1) 实现 `Runnable` 接口</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2) 重写 `run()` 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyRunnable</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 创建线程对象</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="3"><li><span style="color:rgb(122 116 116);">（前两种方式都不能拿到线程的返回值）</span> 实现 <code>Callable</code> 接口，重写 <code>call()</code> 方法，返回值通过 <code>FutureTask</code> 进行封装</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1) 实现 `Callable` 接口，返回值为 Integer</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 2) 重写 `call()` 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyCallable</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 创建线程对象</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>还有<strong>两种有歧义的方式</strong>（不建议回答，但可以了解，并明白它们的本质）：</p> <ol><li>Lambda表达式实现 <code>Runnable</code> 接口的方法</li> <li>使用线程池创建：
<ul><li>1）通过 <code>ThreadPoolExecutor</code> 构造函数创建（✅推荐）
<ul><li><code>new ThreadPoolExecutor(...);</code></li></ul></li> <li>2）通过工具类 <code>Executors</code> 来创建（❎不推荐）
<ul><li><code>Executors.newCachedThreadPool(...);</code></li> <li><code>Executors.newFixedThreadPool(...);</code></li> <li><code>Executors.newSingleThreadExecutor(...);</code></li> <li><code>Executors.newScheduledThreadPool(...);</code></li></ul></li></ul></li></ol></div></div><h4 id="⚪-使用runnable和callable都可以创建线程-它们有什么区别❓"><a href="#⚪-使用runnable和callable都可以创建线程-它们有什么区别❓" class="header-anchor">#</a> ⚪ 使用Runnable和Callable都可以创建线程，它们有什么区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li>定义和返回值：
<ul><li>Runnable 接口定义的是 <strong>没有返回值的<code>run()</code>方法</strong></li> <li>Callable 接口定义了的是 <strong>有返回值的 <code>call()</code> 方法</strong></li></ul></li> <li>异常处理：
<ul><li>Runnable 接口的 <code>run()</code> 方法不能抛出异常（受检查异常），只能在方法内部进行异常处理</li> <li>Callable 接口的 <code>call()</code> 方法可以抛出异常，调用者需要进行相应的异常处理</li></ul></li> <li>返回结果：
<ul><li>Runnable 接口的 <code>run()</code> 方法没有返回值，无法获取任务的执行结果</li> <li>Callable 接口的 <code>call()</code> 方法有返回值（泛型类型），配合 <code>Future</code>、<code>FutureTask</code> 获取任务的执行结果</li></ul></li></ol></div></div><h4 id="⚪-在启动线程的时候-可以使用run方法吗-run-和start-有什么区别❓"><a href="#⚪-在启动线程的时候-可以使用run方法吗-run-和start-有什么区别❓" class="header-anchor">#</a> ⚪ 在启动线程的时候，可以使用run方法吗？run()和start()有什么区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）直接回答</p> <p><strong>可以直接执行</strong> <code>run()</code> 方法，但是，这种方式会把 <code>run()</code> 方法当成 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以<strong>这并不是多线程工作</strong></p> <p>（2）分析</p> <p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code> 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</p> <p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p> <p>（3）区别</p> <p>作用：</p> <ul><li><code>start()</code>: 启动一个线程并使线程进入了就绪状态，通过该线程调用 <code>run()</code> 方法，这是真正的多线程工作。</li> <li><code>run()</code>: 封装了要被线程执行的代码。</li></ul> <p>调用次数：</p> <ul><li><code>start()</code>: 只能被调用一次</li> <li><code>run()</code>: 可以被调用多次</li></ul> <p>🧛🏻‍♂️ 引申的两个问题</p> <ul><li>反复调用同一个线程的 <code>start()</code> 方法是否可行？</li> <li>假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 <code>start()</code> 方法是否可行？</li></ul> <p>🙋🏻‍♂️：都不行，在调用 <code>start()</code> 之后，<code>threadStatus</code> 的值会改变（<code>threadStatus !=0</code>），再次调用 <code>start()</code> 方法会抛出 <code>IllegalThreadStateException</code> 异常。</p></div></div><h4 id="⚪-线程包括哪些状态-状态之间是如何变化❓"><a href="#⚪-线程包括哪些状态-状态之间是如何变化❓" class="header-anchor">#</a> ⚪ 线程包括哪些状态，状态之间是如何变化❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）<strong>线程的生命周期和状态</strong></p> <p>Java线程一个有6种不同的状态，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Thread.State 源码 —— 线程状态的枚举类</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
    <span class="token comment">// 新建     —— 线程被创建出来，但没有被调用 start()</span>
    NEW<span class="token punctuation">,</span>            
    <span class="token comment">// 可运行   —— 线程被调用了 start() 等待运行的状态</span>
    RUNNABLE<span class="token punctuation">,</span> 
    <span class="token comment">// 阻塞     —— 需要等待锁释放</span>
    BLOCKED<span class="token punctuation">,</span>        
    <span class="token comment">// 无限等待 —— 处于该状态的线程需要等待其他线程做出一些特定动作</span>
    WAITING<span class="token punctuation">,</span>        
    <span class="token comment">// 限期等待 —— 指定时间后自动返回 RUNNABLE</span>
    TIMED_WAITING<span class="token punctuation">,</span>  
    <span class="token comment">// 终止     —— 表示该线程已运行完毕</span>
    TERMINATED<span class="token punctuation">;</span>     
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>线程的生命周期并不是固定处于某一个状态</strong>，而是随着代码的执行在不同状态之间切换。</p> <p>（2）<strong>线程状态之间是如何变化？</strong></p> <p>如图所示：</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240523173907.png" alt="Java 线程状态变迁图" class="zoom"> <ul><li><code>new Thread()</code> 线程创建之后它将处于 <strong>NEW</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>RUNNABLE</strong> 状态</li> <li>当线程执行 <code>wait()</code> 方法之后，线程进入 <strong>WAITING</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态</li> <li><strong>TIMED_WAITING</strong> 状态相当于在等待状态的基础上增加了超时限制。当超时时间结束后，线程将会返回到 RUNNABLE 状态</li> <li>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait()</code> 后（被 <code>notify()</code>）重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候（等待锁）线程就会进入 <strong>BLOCKED</strong> 状态</li> <li>线程在执行完了 <code>run()</code> 方法之后将会进入到 <strong>TERMINATED</strong> 状态</li></ul></div></div><h4 id="⚪-wait-和sleep-方法的不同❓"><a href="#⚪-wait-和sleep-方法的不同❓" class="header-anchor">#</a> ⚪ wait()和sleep()方法的不同❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>相同点</strong>：两者都是让当前线程暂停执行</p> <p><strong>不同点</strong>：</p> <ul><li><strong>所属类不同</strong>：<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li> <li><strong>锁特性不同</strong>：<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</li> <li><strong>作用场景不同</strong>：
<ul><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code> 通常被用于暂停执行</li> <li>调用 <code>wait()</code> 的前提是该线程必须持有某个锁，<code>sleep()</code> 可以在任何地方调用</li></ul></li> <li><strong>唤醒对象不同</strong>：<code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul></div></div><h4 id="⚪-如何停止一个正在运行的线程❓"><a href="#⚪-如何停止一个正在运行的线程❓" class="header-anchor">#</a> ⚪ 如何停止一个正在运行的线程❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>有三种方式可以停止线程：</p> <ul><li>方式1：使用退出标志，使线程正常退出，也就是 <code>run()</code> 方法完成后线程终止</li> <li>方式2：使用stop方法强行终止。<span style="color:rgb(122 116 116);">（不推荐，方法已作废，这个方法会导致一些清理性的工作得不到完成，如文件，数据库等的关闭，以及数据不一致的问题）</span></li> <li>方式3：使用 <code>interrupt()</code> 方法中断线程
<ul><li>打断阻塞（ sleep，wait，join ）的线程，线程会抛出InterruptedException异常</li> <li>打断正常的线程，可以根据打断状态来标记是否退出线程</li></ul></li></ul> <p>详细参考：</p> <ul><li>https://www.bilibili.com/video/BV13P411b7gw</li> <li>https://baijiahao.baidu.com/s?id=1771200491206091094&amp;wfr=spider&amp;for=pc</li></ul></div></div><h3 id="线程中的并发安全"><a href="#线程中的并发安全" class="header-anchor">#</a> 线程中的并发安全</h3> <h4 id="⚪-synchronized关键字的底层原理❓"><a href="#⚪-synchronized关键字的底层原理❓" class="header-anchor">#</a> ⚪ synchronized关键字的底层原理❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）<strong>底层</strong></p> <p>底层由 monitor 实现，C++ （JVM 底层通过 C++ 实现） 通过 <code>ObjectMonitor</code> 实现了 <code>synchronized</code>。</p> <p>具体来说，每个锁对象都有一个关联的 monitor（监视器），其原理是：锁对象的对象头的 MarkWord (32bit) 中， MarkWord 的 <code>ptr_to_heavyweight_monitor</code> 指针指向 <code>ObjectMonitor</code> 对象</p> <p>在 <code>ObjectMonitor</code> 内部有四个属性，分别是 <code>_count</code> 、<code>_owner</code> 、<code>_EntryList</code>、<code>_WaitSet</code>：</p> <ul><li><code>_count</code>: 计数器，如果不为0则表示当前 <code>ObjectMonitor</code> 对象已被持有，通过计数器实现可重入锁</li> <li><code>_owner</code>: <code>_owner</code> 关联的是当前持有锁的线程（仅有一个），指向当前持有 <code>ObjectMonitor</code> 对象的线程</li> <li><code>_EntryList</code>: <code>_EntryList</code> 关联的是处于 BLOCKED 状态的线程。每个阻塞等待获取锁的线程都会被封装成 <code>ObjectWaiter</code> 对象并进入这里</li> <li><code>_WaitSet</code>: <code>_WaitSet</code> 关联的是处于 WAITING 状态的线程。调用了 <code>wait()</code> 方法后，线程就会进入到这里</li></ul> <p>（2）<strong>加锁和释放锁</strong></p> <p><code>synchronized</code> 采用互斥的方式让同一时刻至多只有一个线程能持有锁对象。加了 <code>synchronized</code> 关键字的地方，可以保证在任意时刻，只有一个线程能执行该方法或代码块。</p> <p>性质：悲观锁、可重入锁</p> <ul><li><strong>加锁</strong>：Monitorenter 指令，使锁对象的计数器+1，如果计数器从0变成1，说明执行该指令的线程成功持有锁</li> <li><strong>释放锁</strong>：Monitorexit 指令，使锁对象的计数器-1，如果计数器从1变成0，说明执行该指令的线程成功释放锁</li></ul> <p>（3）<strong>可重入原理</strong></p> <p><code>synchronized</code> 可重入原理是通过 <strong>JVM 内部维护一个锁对象（锁）的计数器</strong>来实现的。</p> <p>首先，<strong>可重入性是针对同一个线程（锁程）多次获取同一把「锁对象」的情况</strong>。每个「锁对象」都有一个关联的 monitor（监视器），monitor 里包含了一个计数器。</p> <p>当线程尝试进入 <code>synchronized</code> 修饰的同步代码块/方法/..时，会先去查看 <code>synchronized</code> 「锁对象」的计数器：</p> <ol><li>情况1：如果计数器为 0，表示无锁。
<ul><li>当线程会立即获取到「锁对象」，也与对应的 monitor 和计数器产生关联，计数器 + 1；</li> <li>其他线程不能再获取「锁对象」，进入同步队列（SynchronizedQueue）等待。</li></ul></li> <li>情况2：如果计数器不为 0，并且该线程已经关联了该「锁对象」的 monitor，说明已经拿到了锁对象的所有权。
<ul><li>则表示该线程重入了这把锁，计数器 +1；</li> <li>随着重入的次数，计数器一直累加。</li> <li>相反的，退出同步代码块时，计数器 -1，直到计数器为 0 时，表示该线程释放了锁。</li></ul></li> <li>情况3：如果计数器不为 0，而该线程并没有关联 monitor，说明锁被别的线程持有，该线程需要等待锁的释放。</li></ol> <p>（4）锁升级</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240524103959.png" alt="锁升级细化流程" class="zoom"></div></div><h4 id="⚪-谈谈-jmm-java内存模型-❓"><a href="#⚪-谈谈-jmm-java内存模型-❓" class="header-anchor">#</a> ⚪ 谈谈 JMM（Java内存模型）❓</h4> <h4 id="⚪-谈谈-cas-另外什么是悲观锁和乐观锁❓"><a href="#⚪-谈谈-cas-另外什么是悲观锁和乐观锁❓" class="header-anchor">#</a> ⚪ 谈谈 CAS，另外什么是悲观锁和乐观锁❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）<strong>悲观锁和乐观锁</strong></p> <ul><li><strong>悲观锁</strong>：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会<strong>上锁</strong>，其他线程想拿到这个资源就需要（阻塞）<strong>等待锁被释放</strong> <ul><li><code>synchronized</code> 和 <code>ReentrantLock</code> 属于悲观锁</li></ul></li> <li><strong>乐观锁</strong>：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，所以<strong>不会</strong>对共享资源<strong>上锁</strong>，获取资源操作也<strong>无需等待</strong>，只是在提交修改的时候去<strong>验证</strong>对应的资源（也就是数据）<strong>是否</strong>被其它线程<strong>修改</strong>了
<ul><li>一般会使用版本号机制或 CAS 算法实现乐观锁</li> <li><code>java.util.concurrent.atomic</code> 包下面的原子变量类（比如 <code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了 CAS 实现的</li></ul></li></ul> <p><strong>适用场景</strong>：</p> <ul><li>悲观锁通常多用于写比较多的情况（<strong>多写场景</strong>，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。</li> <li>乐观锁通常多用于写比较少的情况（<strong>多读场景</strong>，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考 <code>java.util.concurrent.atomic</code> 包下面的原子变量类）。</li></ul> <p>（2）<strong>CAS — 乐观锁的一种实现方式</strong></p> <p>CAS 全称 Compare And Swap（比较再交换），用于实现乐观锁。CAS 的思想很简单，就是用一个预期值 <code>E</code> 和要更新的变量值 <code>V</code> 进行比较，两值相等才会进行更新。</p> <p><strong>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</strong></p> <p>具体来说，CAS 操作涉及三个操作数：</p> <ul><li><code>V</code> : Var. 要修改的变量的内存位置</li> <li><code>E</code> : Expected. 预期旧值</li> <li><code>N</code> : New. 拟写入的新值</li></ul> <p>当想要对一个变量执行 CAS 时，<strong>其执行流程</strong>：</p> <ol><li>执行前：记录 <code>V</code> 和 <code>E</code> 预期旧值</li> <li>执行时：获取 <code>V</code> 目前的值和 <code>E</code> 预期旧值进行对比（Compare）
<ul><li>如果相等，说明该变量没有被其他线程修改，因此将新值 <code>N</code> 更新到 <code>V</code> 上（Swap）；</li> <li>如果不相等，说明该变量被其他线程修改了，当前线程此次修改失败，允许再次尝试修改，即通过自旋进行下一轮 CAS。</li></ul></li></ol> <ul><li><strong>优点</strong>：无需对共享资源加锁，线程不会阻塞</li> <li><strong>缺点/问题</strong>：
<ul><li>ABA 问题</li> <li>循环时间长开销大：多个线程对共享资源进行修改时，CAS 竞争激烈，导致频繁失败和自旋重试</li> <li>只能保证一个共享变量的原子操作</li></ul></li></ul> <blockquote><p>Java 语言并没有直接实现 CAS，底层依赖于 <code>sun.misc</code> 包下的 <code>Unsafe</code> 类来直接调用操作系统底层的 CAS 指令。</p> <p><code>Unsafe</code> 类提供了 <code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code> 本地方法，来实现的对 <code>Object</code>、<code>int</code>、<code>long</code> 类型的 CAS 操作，这些本地方法是通过 C++ 内联汇编的形式实现的（JNI 调用）。</p></blockquote></div></div><h4 id="⚪-请谈谈你对-volatile-的理解❓"><a href="#⚪-请谈谈你对-volatile-的理解❓" class="header-anchor">#</a> ⚪ 请谈谈你对 volatile 的理解❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>一个共享变量（类的成员变量、类的静态成员变量）被 <code>volatile</code> 修饰之后，那么就具备了两层语义：</p> <ol><li>保证线程间的可见性</li></ol> <p>用 <code>volatile</code> 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p> <ol start="2"><li>禁止进行指令重排序</li></ol> <p>指令重排：用 <code>volatile</code> 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p> <p><strong>总结</strong>：</p> <p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p></div></div><h4 id="⚪-请你说一下自己对于-aqs-原理的理解❓"><a href="#⚪-请你说一下自己对于-aqs-原理的理解❓" class="header-anchor">#</a> ⚪ 请你说一下自己对于 AQS 原理的理解❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>AQS 全称是 <strong>A</strong>bstract<strong>Q</strong>ueued<strong>S</strong>ynchronizer，即抽象队列同步器。</p> <p>AQS是一个用来构建锁和同步器的<strong>框架</strong>，许多同步类实现都依赖于 AQS，如常用的 <code>ReentrantLock</code> / <code>Semaphore</code> / <code>CountDownLatch</code> 等。</p> <p>（1）核心思想</p> <p><strong>最主要的，AQS 维护了一个代表共享资源的 <code>state</code> 属性和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）：</strong></p> <ol><li><code>state</code> 共享资源:
<ul><li><code>volatile int state;</code> 随着具体实现的不同，表达的含义也不相同
<ul><li>以 <code>ReentrantLock</code> 为例，初始值为 <code>0</code> ，表示无锁状态。线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code>，因此值大于 0 表示锁定状态。</li> <li>以 <code>CountDownLatch</code> 以例，初始值为 <code>n</code>，表示 n 个子线程执行。每个子线程执行完后 <code>countDown()</code> 一次，将 <code>state-1</code>，因此最后值为 0 表示执行完毕。</li></ul></li> <li>访问 <code>state</code> 有三种方式：<code>getState()</code> 、 <code>setState(int newState)</code> 、 <code>compareAndSetState(int expect, int update)</code></li></ul></li> <li>FIFO 线程等待队列：
<ul><li>将暂时获取不到锁的线程加入到该队列中</li> <li>该队列由 CLH 队列锁实现，一个虚拟的双向队列（不存在队列实例，仅存在结点之间的关联关系）</li> <li>AQS 是将每条请求共享资源的线程封装成 CLH 锁队列的一个结点(<code>Node</code>)来实现锁的分配</li></ul></li></ol> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240526161904.png" alt="Sync queue" class="zoom"> <p>（2）AQS 对资源的共享方式</p> <p>AQS定义两种资源共享方式：</p> <ul><li><strong>独占方式 / Exclusive</strong>：只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：
<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li> <li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li> <li><strong>共享方式 / Share</strong>：多个线程可同时执行，如 <code>Semaphore</code> 、 <code>CountDownLatch</code>。</li></ul></div></div><h4 id="⚪-reentrantlock的实现原理❓"><a href="#⚪-reentrantlock的实现原理❓" class="header-anchor">#</a> ⚪ ReentrantLock的实现原理❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）内部类</p> <p><code>ReentrantLock</code> 主要利用 AQS 来实现公平锁或非公平锁。默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p> <p><code>ReentrantLock</code> 总共有三个内部类：<code>Sync</code>、<code>NonfairSync</code>、<code>FairSync</code>。<code>NonfairSync</code> 与 <code>FairSync</code> 类继承自 <code>Sync</code> 类，<code>Sync</code> 类继承自<code>AbstractQueuedSynchronizer</code> 抽象类 AQS。如图所示：</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240526164006.png" alt="20240526164006" class="zoom"> <p><code>Sync</code> 类继承自 AQS，并实现了 AQS 提供的两个模板方法 <code>tryRelease(int releases)</code> 和 <code>tryAcquire(int acquires)</code> 。</p> <p>（2）核心</p> <p><code>ReentrantLock</code> 内有一个 <code>Sync</code> 类型的属性 <code>sync</code> ，我们对 <code>ReentrantLock</code> 的很多操作都转化为对 <code>sync</code> （即 <code>Sync</code> 对象）的操作，由于 <code>Sync</code> 继承了 AQS，所以基本上都可以转化为对 AQS 的操作。</p> <p>所以可知，在 <code>ReentrantLock</code> 的背后，是AQS对其服务提供了支持。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 同步队列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
<span class="token comment">// 默认非公平策略</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 传递参数确定采用公平策略或者是非公平策略</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></div></div><h4 id="⚪-synchronized和lock有什么区别❓"><a href="#⚪-synchronized和lock有什么区别❓" class="header-anchor">#</a> ⚪ synchronized和Lock有什么区别❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>区别：</p> <ul><li><strong>实现不同</strong>：
<ul><li>synchronized 是关键字，源码在 JVM 中，用 C++ 语言实现</li> <li>Lock 是接口，源码由 JDK 提供，用 Java 语言实现</li></ul></li> <li><strong>释放锁不同</strong>：
<ul><li>使用 synchronized 时，退出同步代码块锁会自动释放</li> <li>使用 Lock 时，需要手动调用 unlock 方法配合 <code>try...finally...</code> 释放锁</li></ul></li> <li><strong>锁对象不同</strong>：
<ul><li>synchronized 加锁和释放的时机单一，每个锁仅有一个单一的条件</li> <li>Condition 与 Lock 的结合可以做到加锁与多个条件相关联</li></ul></li> <li><strong>可否中断</strong>：
<ul><li>synchronized 试图获取锁的时候不能设定超时，也不能中断一个正在使用锁的线程</li> <li>Lock 可以中断和设置超时（<code>lock.lockInterruptibly()</code>），即正在等待的线程可以选择放弃等待</li></ul></li> <li>synchronized 无法知道是否成功获得锁。相对而言，Lock 可以拿到状态，如果成功获取锁，....，如果获取失败，.....</li> <li>Lock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁</li></ul> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240526020753.png" alt="Synchronized有什么样的缺陷？Java Lock是怎么弥补这些缺陷的？" class="zoom"></div></div><h4 id="⚪-死锁产生的条件是什么❓"><a href="#⚪-死锁产生的条件是什么❓" class="header-anchor">#</a> ⚪ 死锁产生的条件是什么❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><blockquote><p>死锁（Deadlock）描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。<br>
—— JavaGuide</p></blockquote> <p>死锁指两个以上的运算单元（进程、线程、虚拟线程/协程），都在等待对方释放资源，但没有一方提前释放资源，所造成的阻塞现象就叫做死锁。</p> <p><strong>产生死锁的四个必要条件</strong>：</p> <ul><li><strong>互斥</strong>条件：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li> <li><strong>占有并等待</strong>条件：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li> <li><strong>不可剥夺</strong>条件：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li> <li><strong>环路等待</strong>条件：有一组等待进程 <code>{P0, P1,..., Pn}</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul> <p>⚠️注意：这四个条件是产生死锁的必要条件，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p></div></div><h4 id="⚪-如何进行死锁诊断❓"><a href="#⚪-如何进行死锁诊断❓" class="header-anchor">#</a> ⚪ 如何进行死锁诊断❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）<strong>诊断</strong></p> <p>当程序出现了死锁现象，我们可以使用JDK自带的工具：jps 和 jstack</p> <ul><li>jps：输出JVM中运行的进程状态信息</li> <li>jstack：查看Java进程内线程的堆栈信息，查看日志，检查是否有死锁。如果有死锁现象，需要查看具体代码分析后，可修复</li> <li>可视化工具 jconsole、VisualVM 也可以检查死锁问题</li></ul> <p>（2）<strong>解决死锁</strong></p> <p>Java中解决死锁的方法：</p> <ol><li>打破环路等待条件：顺序锁（获取锁的顺序是一致），按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li> <li>打破占有并等待条件：
<ul><li>一次性申请所有的资源</li> <li>使用 <code>ReentrantLock</code> 的 <code>tryLock</code> 方法</li></ul></li> <li>打破不可剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源</li></ol></div></div><h4 id="⚪-聊一下concurrenthashmap❓"><a href="#⚪-聊一下concurrenthashmap❓" class="header-anchor">#</a> ⚪ 聊一下ConcurrentHashMap❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>ConcurrentHashMap 的实现在 JDK1.7 和 JDK 1.8 有很大不同。</p> <ol><li>底层数据结构：
<ul><li>JDK1.7 采用的数据结构是 <code>Segment</code> 数组 + <code>HashEntry</code> 数组 + 链表</li> <li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，<code>Node</code> 数组 + 链表 / 红黑树</li></ul></li> <li>加锁的方式
<ul><li>JDK1.7 采用 Segment 分段锁机制，底层使用的是 <code>ReentrantLock</code></li> <li>JDK1.8 采用 CAS 添加新节点，采用 <code>synchronized</code> 锁定链表或红黑二叉树的首节点，相对Segment 分段锁粒度更细，性能更好。（<span style="color:rgb(122 116 116);">CAS保证添加节点时没有多线程冲突，<code>synchronized</code> 保证访问 Map 时没有多线程冲突</span>）</li></ul></li></ol> <p>https://zhuanlan.zhihu.com/p/31614308</p></div></div><h4 id="⚪-导致并发程序出现问题的根本原因是什么❓"><a href="#⚪-导致并发程序出现问题的根本原因是什么❓" class="header-anchor">#</a> ⚪ 导致并发程序出现问题的根本原因是什么❓</h4> <p>换一种问法：Java程序中怎么保证多线程的执行安全？</p> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>并发程序出现问题，<strong>其根源是并发三要素/三问题</strong>：可见性、原子性、有序性</p> <ul><li><strong>可见性</strong>：一个线程对共享变量的修改，另外一个线程能够立刻看到</li> <li><strong>原子性</strong>：即 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</li> <li><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行</li></ul> <p><strong>在保证这三者生效的情况下，Java程序可以保证多线程的安全执行。若出现并发问题，便是这三者中的其中一个或多个无法得到保证</strong>，比如：</p> <ul><li>CPU 缓存 破坏了 可见性</li> <li>时分复用 破坏了 原子性</li> <li>重排序（Instruction Reorder） 破坏了 有序性</li></ul> <p><strong>解决方法</strong>：</p> <ol><li>原子性：<code>synchronized</code>、<code>Lock</code></li> <li>可见性：<code>volatile</code>、<code>synchronized</code>、<code>Lock</code> <ul><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。</li> <li><code>synchronized</code> 关键字两者都能保证。</li></ul></li> <li>有序性：<code>volatile</code> <ul><li>用 <code>volatile</code> 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li></ul></li></ol></div></div><h3 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h3> <h4 id="⚪-说一下线程池的核心参数-线程池的执行原理知道嘛-❓"><a href="#⚪-说一下线程池的核心参数-线程池的执行原理知道嘛-❓" class="header-anchor">#</a> ⚪ 说一下线程池的核心参数（线程池的执行原理知道嘛）❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>Executors 线程池的类结构关系：</p> <p><img src="/blog/assets/img/image-9.474dd47d.png" alt="alt text"></p> <p>线程池实现类 <code>ThreadPoolExecutor</code> 是 Executor 框架最核心的类。</p> <p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p> <p>（1）<strong>线程池的7个参数</strong></p> <p>线程池 <code>ThreadPoolExecutor</code> 的<strong>7个参数</strong>：</p> <ol><li>线程池的<strong>核心线程数量</strong>：<code>int corePoolSize</code></li> <li>线程池的<strong>最大线程数</strong>（核心线程+临时线程数）：<code>int maximumPoolSize</code></li> <li>临时线程的<strong>最大空闲时间</strong>（超过这个时间，临时线程就释放掉）：<code>long keepAliveTime</code></li> <li>参数3的<strong>时间单位</strong>（秒/天/...）：<code>TimeUnit unit</code></li> <li>线程池<strong>任务队列</strong>（是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中）：<code>BlockingQueue&lt;Runnable&gt; workQueue</code></li> <li><strong>线程工厂</strong>（创建线程所用的工厂）：<code>ThreadFactory threadFactory</code></li> <li><strong>拒绝策略</strong>（当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务）：<code>RejectedExecutionHandler handler</code></li></ol> <p>源码如下（忽略细节）：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>       <span class="token comment">// 核心线程数量</span>
        <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>    <span class="token comment">// 最大线程数</span>
        <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>     <span class="token comment">// 最大空闲时间</span>
        <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>          <span class="token comment">// 时间单位</span>
        <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>  <span class="token comment">// 阻塞/任务队列</span>
        <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>        <span class="token comment">// 线程工厂</span>
        <span class="token class-name">RejectedExecutionHandler</span> handler    <span class="token comment">// 拒绝策略</span>
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>（2）<strong>线程池的执行原理/流程</strong></p> <p>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code> 方法，该方法的实现在 <code>ThreadPoolExecutor</code> 类中。</p> <div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-java"><code>   <span class="token comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//任务队列</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果任务为null，则抛出异常。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ctl 中保存的线程池当前的一些状态信息</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//  下面会涉及到 3 步 操作</span>
        <span class="token comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span>
        <span class="token comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span>
        <span class="token comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果当前工作线程数量为0，新创建一个线程并执行。</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span class="token comment">// 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span>
        <span class="token comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>线程池处理任务的流程：</p> <p><img src="/blog/assets/img/image-13.3a0fcb8f.png" alt="图解线程池实现原理"></p> <ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个核心线程 <code>addWorker(command, true)</code> 来执行任务。</li> <li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数：
<ul><li>那么就把该任务放入到任务队列里等待执行</li> <li><strong>如果当前运行的线程数为0，则新建一个临时线程</strong> <code>addWorker(null, false);</code>，</li></ul></li> <li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个临时线程来执行任务。</li> <li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用 <code>RejectedExecutionHandler.rejectedExecution()</code> 方法。</li></ol> <p>（3）<strong><code>ThreadPoolExecutor</code> 拒绝策略</strong></p> <p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolExecutor</code> 定义一些策略:</p> <ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li> <li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li> <li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li> <li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li></ul> <hr> <p>扩展问题：</p> <p>🧛🏻‍♂️ 问：线程池的核心线程设置为0，任务来了之后怎么做？</p> <p>🙋🏻‍♂️ 答：核心线程数设置为0，当任务来了之后，也会创建一个线程来执行任务，</p></div></div><h4 id="⚪-线程池中有哪些常见的阻塞队列❓"><a href="#⚪-线程池中有哪些常见的阻塞队列❓" class="header-anchor">#</a> ⚪ 线程池中有哪些常见的阻塞队列❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在此（阻塞）任务队列中。</p> <p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p> <table><thead><tr><th>阻塞队列</th> <th>内置线程池</th> <th>说明</th></tr></thead> <tbody><tr><td><code>LinkedBlockingQueue</code>（无界队列）</td> <td><code>FixedThreadPool</code> 和 <code>SingleThreadExector</code></td> <td>容量为 <code>Integer.MAX_VALUE</code>。<code>FixedThreadPool</code> 最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code> 只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</td></tr> <tr><td><code>SynchronousQueue</code>（同步队列）</td> <td><code>CachedThreadPool</code></td> <td><code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</td></tr> <tr><td><code>DelayedWorkQueue</code>（延迟阻塞队列）</td> <td><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></td> <td><code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</td></tr></tbody></table></div></div><h4 id="⚪-如何确定核心线程数❓"><a href="#⚪-如何确定核心线程数❓" class="header-anchor">#</a> ⚪ 如何确定核心线程数❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li><strong>高并发、任务执行时间短</strong> →（ CPU核数+1 ），减少线程上下文的切换</li> <li><strong>并发不高、任务执行时间长</strong> <ul><li>IO密集型的任务 → (CPU核数 * 2 + 1)，<span style="color:rgb(122 116 116);">举例：文件读写、DB读写、网络请求等</span></li> <li>计算密集型任务 →（ CPU核数+1 ），<span style="color:rgb(122 116 116);">举例：计算型代码、Bitmap转换、Gson转换</span></li></ul></li> <li><strong>并发高、业务执行时间长</strong>，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考第2条</li></ol></div></div><h4 id="⚪-线程池的种类有哪些❓"><a href="#⚪-线程池的种类有哪些❓" class="header-anchor">#</a> ⚪ 线程池的种类有哪些❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ul><li>newFixedThreadPool：创建一个 <strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待</li> <li>newSingleThreadExecutor：创建一个 <strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</li> <li>newCachedThreadPool：创建一个 <strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li> <li>newScheduledThreadPool：可以 <strong>执行延迟任务的线程池</strong>，支持定时及周期性任务执行</li></ul></div></div><h4 id="⚪-为什么不建议用executors创建线程池❓"><a href="#⚪-为什么不建议用executors创建线程池❓" class="header-anchor">#</a> ⚪ 为什么不建议用Executors创建线程池❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p> <blockquote><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote> <p>另外，《阿里巴巴 Java 开发手册》中强制线程池 <strong>不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式</strong>，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527104710.png" alt="线程池对象的弊端" class="zoom"></div></div><h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <h4 id="⚪-线程池使用场景-你们项目中哪里用到了线程池-❓"><a href="#⚪-线程池使用场景-你们项目中哪里用到了线程池-❓" class="header-anchor">#</a> ⚪ 线程池使用场景(你们项目中哪里用到了线程池)❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ul><li><strong>批量导入</strong>：使用了“线程池+CountDownLatch”批量把数据库中的数据导入到ES(任意)中，避免OOM</li> <li><strong>数据汇总</strong>：调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用“线程池+Future”来提升性能</li> <li><strong>异步线程（线程池）</strong>：为了避免下一级方法影响上一级方法（性能考虑），可使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间</li></ul></div></div><h4 id="⚪-如何控制某个方法允许并发访问线程的数量❓"><a href="#⚪-如何控制某个方法允许并发访问线程的数量❓" class="header-anchor">#</a> ⚪ 如何控制某个方法允许并发访问线程的数量❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><code>Semaphore</code> [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，底层是 AQS，我们可以通过其限制执行的线程数量。</p> <p>使用场景：通常用于那些资源有明确访问数量限制的场景，常用于限流。</p> <p>使用步骤：</p> <ol><li>创建 <code>Semaphore</code> 对象，可以给一个容量</li> <li><code>semaphore.acquire()</code>：请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</li> <li><code>semaphore.release()</code>：释放一个信号量，此时信号量个数+1</li></ol> <div class="language-java line-numbers-mode"><div class="highlight-lines"><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br></div><pre class="language-java"><code><span class="token comment">// 1. 创建 Semaphore 对象</span>
<span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 10个线程同时运行</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 2. 请求一个信号量，获取许可</span>
      semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;running...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;end...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      <span class="token comment">// 3. 释放一个信号量，释放许可</span>
      semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div></div></div><h4 id="⚪-谈谈你对threadlocal的理解❓"><a href="#⚪-谈谈你对threadlocal的理解❓" class="header-anchor">#</a> ⚪ 谈谈你对ThreadLocal的理解❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li><code>ThreadLocal</code> 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li> <li><code>ThreadLocal</code> 同时实现了线程内的资源共享</li> <li>每个线程内有一个 <code>ThreadLocalMap</code> 类型的成员变量，用来存储资源对象
<ul><li>调用 <code>set</code> 方法，就是以 <code>ThreadLocal</code> 自己作为 key，资源对象作为 value，放入当前线程的 <code>ThreadLocalMap</code> 集合中</li> <li>调用 <code>get</code> 方法，就是以 <code>ThreadLocal</code> 自己作为 key，到当前线程中查找关联的资源值</li> <li>调用 <code>remove</code> 方法，就是以 <code>ThreadLocal</code> 自己作为 key，移除当前线程关联的资源值</li></ul></li> <li><code>ThreadLocal</code> 内存泄漏问题
<code>ThreadLocalMap</code> 中的 key 是弱引用，值为强引用； key 会被 GC 释放内存，关联 value 的内存并不会释放。建议主动 <code>remove</code> 释放 key，value</li></ol></div></div><h2 id="jvm虚拟机篇"><a href="#jvm虚拟机篇" class="header-anchor">#</a> JVM虚拟机篇</h2> <p><img src="/blog/assets/img/image-20.06053337.png" alt="alt text"></p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527153720.png" alt="20240527153720" class="zoom"> <h3 id="jvm组成"><a href="#jvm组成" class="header-anchor">#</a> JVM组成</h3> <h4 id="⚪什么是程序计数器❓"><a href="#⚪什么是程序计数器❓" class="header-anchor">#</a> ⚪什么是程序计数器❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p> <p>另外，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。</p> <p>从上面的介绍中我们知道了<strong>程序计数器主要有两个作用</strong>：</p> <ol><li>字节码解释器 <strong>通过改变程序计数器</strong> 来依次读取指令，从而 <strong>实现代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li> <li>在多线程的情况下，程序计数器用于 <strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527153909.png" alt="20240527153909" class="zoom"> <p>⚠️ 注意：程序计数器是 <strong>唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></div></div><h4 id="⚪你能给我详细的介绍下堆吗❓"><a href="#⚪你能给我详细的介绍下堆吗❓" class="header-anchor">#</a> ⚪你能给我详细的介绍下堆吗❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）Java堆</p> <p>Java 堆是 JVM 所管理的 <strong>内存中最大的一块</strong>，是所有 <strong>线程共享</strong> 的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p> <blockquote><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p></blockquote> <p>Java <strong>堆是垃圾收集器管理的主要区域</strong>，因此也被称作 <strong>GC 堆</strong>（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。如图所示：</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527170146.png" alt="Java堆分代" class="zoom"> <p>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，<strong>元空间使用的是本地内存</strong>。</p> <p>（2）可能的异常</p> <p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误。当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出 <code>OutOfMemoryError</code> 异常。</p> <p>（3）字符串常量池</p> <p><span style="color:rgb(122 116 116);">JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</span></p> <p>字符串常量池 是 JVM 为了提升性能和减少内存消耗 <strong>针对字符串（String 类）专门开辟的一块区域</strong>，主要目的是为了 <strong>避免字符串的重复创建</strong>。</p> <p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的 HashTable ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p> <hr> <p>扩展问题</p> <p>🧛🏻‍♂️ 问：为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</p> <p>🙋🏻‍♂️ 答：</p> <ol><li>避免空间 OOM：整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li> <li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li> <li>元空间里面存放的是类的元数据，放在本地内存时，由系统的实际可用空间来控制，这样能加载的类就更多。</li></ol></div></div><h4 id="⚪能不能介绍一下方法区❓"><a href="#⚪能不能介绍一下方法区❓" class="header-anchor">#</a> ⚪能不能介绍一下方法区❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>关键字</strong>：类信息、运行时常量池、常量池表</p> <p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个 <strong>线程共享</strong> 的内存区域。</p> <p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p> <p>（2）运行时常量池</p> <p><strong>运行时常量池是方法区的一部分</strong>。</p> <p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong>。<strong>常量池表会在类加载后存放到方法区的运行时常量池中</strong>。</p> <ul><li>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。</li> <li>常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</li></ul></div></div><h4 id="⚪你听过直接内存吗❓"><a href="#⚪你听过直接内存吗❓" class="header-anchor">#</a> ⚪你听过直接内存吗❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>直接内存：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高</p></div></div><h4 id="⚪什么是虚拟机栈❓"><a href="#⚪什么是虚拟机栈❓" class="header-anchor">#</a> ⚪什么是虚拟机栈❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>关键字</strong>：方法调用、栈帧</p> <p>（1）<strong>概述</strong></p> <p>虚拟机栈（JVM Stack）是 Java 运行时数据区的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的，<strong>其他所有的 Java 方法调用都是通过栈来实现</strong> 的。</p> <p>栈由一个个栈帧组成，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p> <p>（2）<strong>栈帧</strong></p> <p>每一次方法调用都生成一个栈帧，栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</p> <ul><li>局部变量表：存放了编译期可知的各种数据类型、对象引用</li> <li>操作数栈：用于存放该方法执行过程中产生的中间计算结果、临时变量</li> <li>动态链接：将符号引用转换为调用方法的直接引用，便于服务一个方法需要调用其他方法的场景</li> <li>方法返回地址：用来存放调用该方法的 PC 寄存器的值</li></ul> <p>（3）<strong>可能的异常</strong></p> <ul><li>栈固定大小时可能 <code>StackOverflowError</code></li> <li>栈动态扩展时可能 <code>OutOfMemoryError</code></li></ul> <hr> <p><strong>扩展问题</strong></p> <p>🧛🏻‍♂️ 问：垃圾回收是否涉及栈内存?</p> <p>🙋🏻‍♂️ 答：不涉及。垃圾回收主要在堆内存区域中；对于虚拟机栈，当栈帧弹出栈以后，内存就会释放。</p> <p>🧛🏻‍♂️ 问：方法内的局部变量是否线程安全?</p> <p>🙋🏻‍♂️ 答：</p> <ul><li>如果方法内的局部变量没有逃离方法的作用范围，那么是线程安全的</li> <li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></div></div><h4 id="⚪什么情况下会导致栈内存溢出❓"><a href="#⚪什么情况下会导致栈内存溢出❓" class="header-anchor">#</a> ⚪什么情况下会导致栈内存溢出❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>如果 <strong>函数调用陷入无限循环</strong> 的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度 <strong>超过当前 Java 虚拟机栈的最大深度</strong> 的时候，就抛出 <code>StackOverFlowError</code> 错误。</p></div></div><h4 id="⚪堆栈的区别是什么❓"><a href="#⚪堆栈的区别是什么❓" class="header-anchor">#</a> ⚪堆栈的区别是什么❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><blockquote><p>栈是运行时的单位，而堆是存储的单位。</p> <p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p></blockquote></div></div><h3 id="类加载器"><a href="#类加载器" class="header-anchor">#</a> 类加载器</h3> <h4 id="⚪-什么是类加载器-类加载器有哪些❓"><a href="#⚪-什么是类加载器-类加载器有哪些❓" class="header-anchor">#</a> ⚪ 什么是类加载器，类加载器有哪些❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p><strong>类加载器</strong>：用于将字节码文件（<code>.class</code> 文件）加载到JVM中，实现类加载过程中的 加载/Loading 这一步，从而让Java程序能够启动起来。</p> <p>站在Java开发人员的角度来看，<strong>类加载器可以大致划分为三类</strong>，这也是 JVM 中内置的三个重要 <code>ClassLoader</code>：</p> <ol><li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++ 实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/jre/lib</code> 目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code> 等 jar 包和类）以及被 <code>-Xbootclasspath</code> 参数指定的路径下的所有类。启动类加载器是无法被Java程序直接引用的。</li> <li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JAVA_HOME%/jre/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。开发者可以直接使用扩展类加载器。</li> <li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，该类加载器由sun.misc.<code>Launcher$AppClassLoader</code> 来实现，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li> <li>（自定义）用户还可以 <strong>自定义类加载器</strong>，自定义类加载器需要继承 <code>ClassLoader</code> 抽象类，重写 <code>findClass()</code> 和  <code>loadClass()</code> 方法</li></ol> <blockquote><p>🌈 拓展一下：</p> <ul><li><strong><code>rt.jar</code></strong>：rt 代表“RunTime”，<code>rt.jar</code> 是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code> 都在里面，比如 <code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。
Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</li></ul></blockquote></div></div><h4 id="⚪-什么是双亲委派模型❓"><a href="#⚪-什么是双亲委派模型❓" class="header-anchor">#</a> ⚪ 什么是双亲委派模型❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>当某个类加载器打算加载某一个类时，不会自己去执行，而是先委托上一级的加载器进行加载。如果上级加载器也有上级，则会继续向上委托，如果该类委托上级加载失败，子加载器再尝试加载该类。</p> <p>简单总结一下双亲委派机制的执行流程：</p> <ul><li>在类加载的时候，系统会首先判断当前类是否被加载过 <code>findLoadedClass(name)</code>。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li> <li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>parent.loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li> <li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li> <li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li></ul></div></div><h4 id="⚪-jvm为什么采用双亲委派机制❓"><a href="#⚪-jvm为什么采用双亲委派机制❓" class="header-anchor">#</a> ⚪ JVM为什么采用双亲委派机制❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ul><li>避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</li> <li>保证了 Java 的核心 API 不被篡改。</li></ul></div></div><h4 id="⚪-说一下类装载的执行过程❓"><a href="#⚪-说一下类装载的执行过程❓" class="header-anchor">#</a> ⚪ 说一下类装载的执行过程❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>类装载的整个生命周期：</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527194710.png" alt="20240527194710" class="zoom"> <p><strong>类加载过程</strong>：</p> <ul><li><strong>Step1 加载/Loading</strong>：
<ul><li>查找并加载类的二进制字节流</li> <li>将字节流所代表的 静态存储结构 转换为 方法区的运行时数据结构</li> <li>在内存（Java堆）中生成一个代表该类的「Class对象」，作为方法区中这些数据的访问入口</li></ul></li> <li><strong>Step2 验证/Verifcation</strong>：
<ul><li>确保被加载的类的正确性，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</li></ul></li> <li><strong>Step3 准备/Preparation</strong>：
<ul><li>为类的静态变量分配内存（方法区中分配），并将其初始化为默认值；</li></ul></li> <li><strong>Step4 解析/Resolution</strong>：
<ul><li>把类中常量池内的「符号引用」替换为「直接引用」；</li> <li><img src="/blog/assets/img/image-21.465bfe22.png" alt="alt text"></li></ul></li> <li><strong>Step5 初始化/Initialization</strong>：
<ul><li>执行初始化方法 <code>&lt;clinit&gt;()</code>，为类的静态变量赋予正确的初始值</li> <li><strong>只有当对类的主动使用的时候才会导致类的初始化</strong>，有以下6种情况：
<ul><li>创建类的实例，也就是 new 的方式</li> <li>访问某个类或接口的静态变量，或者对该静态变量赋值</li> <li>调用类的静态方法</li> <li>反射(如<code>Class.forName(&quot;com.pdai.jvm.Test&quot;)</code>)</li> <li>初始化某个类的子类，则其父类也会被初始化</li> <li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用 <code>java.exe</code> 命令来运行某个主类</li></ul></li></ul></li></ul></div></div><h3 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h3> <h4 id="⚪-对象什么时候可以被垃圾器回收❓"><a href="#⚪-对象什么时候可以被垃圾器回收❓" class="header-anchor">#</a> ⚪ 对象什么时候可以被垃圾器回收❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>对堆进行垃圾回收（GC）前的第一步就是要判断哪些对象已经死亡。</p> <p>简单来说，如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p> <p>要定位哪些对象是垃圾，有 <strong>两种方式</strong> 来确定，第一个是引用计数法，第二个是可达性分析算法（JVM采用这种）。</p> <p>（1）<strong>引用计数法</strong></p> <p>给对象添加一个引用计数器。1）每当有一个地方引用它，计数器+1；2）当引用失效，计数器-1；3）计数器为 0的对象就是垃圾。</p> <p>优点：实现简单，效率高<br>
缺点：很难解决对象之间循环引用的问题</p> <p>（2）<strong>可达性分析算法（JVM采用这种）</strong></p> <p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p> <p><strong>哪些对象可以作为 GC Roots</strong>？</p> <ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li> <li>本地方法栈(Native 方法)中引用的对象</li> <li>方法区中类静态属性引用的对象</li> <li>方法区中常量引用的对象</li> <li>所有被同步锁持有的对象</li> <li>JNI（Java Native Interface）引用的对象</li></ul></div></div><h4 id="⚪-强引用、软引用、弱引用、虚引用❓"><a href="#⚪-强引用、软引用、弱引用、虚引用❓" class="header-anchor">#</a> ⚪ 强引用、软引用、弱引用、虚引用❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p> <p><strong>Java 具有四种强度不同的引用类型：</strong></p> <ol><li>强引用（StrongReference）
<ul><li>被强引用关联的对象 <strong>不会被回收</strong></li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li>软引用（SoftReference）
<ul><li>被软引用关联的对象 <strong>只有在内存不够的情况下才会被回收</strong></li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 把强引用 obj 释放掉，使对象只被软引用 sf 关联</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li> <li>弱引用（WeakReference）
<ul><li>被弱引用关联的对象 <strong>一定会被回收</strong>，也就是说它只能存活到下一次垃圾回收发生之前。</li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li> <li>虚引用（PhantomReference）
<ul><li>形同虚设，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在 <strong>任何时候都可能被垃圾回收</strong>。</li> <li>虚引用主要用来跟踪对象被垃圾回收的活动。</li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li></ol> <p>在程序设计中一般很少使用弱引用与虚引用，<strong>使用软引用的情况较多</strong>，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（<code>OutOfMemory</code>）等问题的产生。</p></div></div><h4 id="⚪-jvm-垃圾回收算法有哪些❓"><a href="#⚪-jvm-垃圾回收算法有哪些❓" class="header-anchor">#</a> ⚪ JVM 垃圾回收算法有哪些❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li><strong>标记-清除算法</strong></li></ol> <p>「标记-清除」（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p> <p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p> <ul><li>效率问题：标记和清除两个过程效率都不高。</li> <li>空间问题：标记清除后会产生大量不连续的内存碎片。</li></ul> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527204314.png" alt="标记-清除算法" class="zoom"> <ol><li><strong>复制算法</strong></li></ol> <p>为了解决「标记-清除」算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以<strong>将内存分为大小相同的两块，每次使用其中的一块</strong>。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p> <p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p> <ul><li>可用内存变小：可用内存缩小为原来的一半。</li> <li>不适合老年代：如果存活对象数量比较大，复制性能会变得很差。</li></ul> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527204427.png" alt="复制算法" class="zoom"> <blockquote><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p> <p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote> <ol><li><strong>标记-整理算法</strong></li></ol> <p>「标记-整理」（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与「标记-清除」算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p> <p>由于多了整理这一步，因此效率也不高，<strong>适合老年代这种垃圾回收频率不是很高的场景</strong>。</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240527204344.png" alt="标记-整理算法" class="zoom"> <ol start="4"><li><strong>分代收集算法</strong></li></ol> <p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。<strong>一般将 Java 堆分为新生代和老年代</strong>，这样我们就可以<strong>根据各个年代的特点选择合适的垃圾收集算法</strong>。</p> <p>比如：</p> <ul><li><strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</li> <li>而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择「<strong>标记-清除</strong>」或「<strong>标记-整理</strong>」算法进行垃圾收集。</li></ul></div></div><h4 id="⚪-说一下jvm中的分代回收❓"><a href="#⚪-说一下jvm中的分代回收❓" class="header-anchor">#</a> ⚪ 说一下JVM中的分代回收❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>（1）分代</p> <p>为了有助于优化对堆内存垃圾回收的性能，将内存划分为 新生代（Young Generation）和老年代（Old Generation）。</p> <p><strong>新生代</strong></p> <ul><li>主要用于存放新创建的对象。新生代会分为三个区域：
<ul><li>Eden（伊甸园，80%）</li> <li>S0（Survivor 0 区，10%）</li> <li>S1（Survivor 1 区，10%）</li></ul></li></ul> <p><strong>老年代</strong></p> <ul><li>一方面，用于存放那些在新生代中经历了多次垃圾回收仍然存活的对象。这些对象通常生命周期较长。</li> <li>另一方面，大对象直接进入老年代，这是内存分配策略之一。</li> <li>（延伸）当老年代空间不足以容纳新存活的对象时，会触发 Full GC，这种GC通常比Minor GC耗时更长，因为它涉及的对象更多，且可能需要暂停所有应用线程。</li></ul> <p>（2）GC 种类</p> <p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p> <ul><li><strong>部分收集 (Partial GC)</strong>：
<ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li> <li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。
<ul><li><span style="color:rgb(122 116 116);">目前，只有 CMS GC 会有单独收集老年代的行为</span></li> <li><span style="color:rgb(122 116 116);">需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</span></li></ul></li> <li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li> <li><strong>整堆收集 (Full GC)</strong>：收集整个 Java 堆和方法区。</li></ul> <p>（3）分代垃圾回收算法执行过程</p> <ul><li>初始态：对象分配在Eden区，S0、S1区几乎为空。</li> <li>随着程序的运行，越来越多的对象被分配在Eden区。</li> <li>当Eden放不下时，就会发生MinorGC（即YoungGC），此时，会先标识出不可达的垃圾对象，然后将可达的对象移动到S0区，并将不可达的对象清理掉。这时候，Eden区就是空的了。在这个过程中，使用了标记清理算法及标记复制算法。</li> <li>随着Eden放不下时，会再次触发minorGC，和上一步一样，先标记。这个时候，Eden和S0区可能都有垃圾对象了，而S1区是空的。这个时候，会直接将Eden和S0区的对象直接搬到S1区，然后将Eden与S0区的垃圾对象清理掉。经历这一轮的MinorGC后，Eden与S0区为空。</li> <li>随着程序的运行，Eden空间会被分配殆尽，这时会重复刚才MinorGC的过程，不过此时，S0区是空的，S0和S1区域会互换，此时存活的对象会从Eden和S1区，向S0区移动。然后Eden和S1区中的垃圾会被清除，这一轮完成之后，这两个区域为空。</li> <li>在程序运行过程中，虽然大多数对象都会很快消亡，但仍然存在一些存活时间较长的对象，对于这些对象，在S0和S1区中反复移动，会造成一定的性能开销，降低GC的效率。因此引入了对象晋升的行为。</li> <li>当对象在新生代的Eden、S0、S1区域之间，每次从一个区域移动到另一个区域时，年龄都会加一，在达到一定的阈值后，如果该对象仍然存活，该对象将会晋升到老年代。</li> <li>如果老年代也被分配完毕后，就会出现MajorGC（即Full GC），由于老年代通常对象比较多，因此标记-整理算法的耗时较长，因此会出现STW现象，因此大多数应用都会尽量减少或着避免出现Full GC的原因。</li></ul></div></div><h4 id="⚪-说一下jvm有哪些垃圾回收器❓"><a href="#⚪-说一下jvm有哪些垃圾回收器❓" class="header-anchor">#</a> ⚪ 说一下JVM有哪些垃圾回收器❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>以下是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p> <p><img src="/blog/assets/img/image-1.2fb8c60d.png" alt="7 个垃圾收集器"></p> <p>前置知识：</p> <ul><li><strong>单线程</strong>&amp;<strong>多线程</strong>: 「单线程」指的是垃圾收集器只使用一个线程进行收集，而「多线程」使用多个线程；</li> <li><strong>串行</strong>&amp;<strong>并行</strong>: 「串行」指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序（必须暂停其他所有的工作线程(&quot;Stop The World&quot;)）；「并行」指的是垃圾收集器和用户程序同时执行。<strong>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行</strong>。</li></ul> <p>简短总结 7 个垃圾收集器：</p> <ul><li><strong>Serial</strong>、<strong>Serial Old</strong>：单线程收集器，适用于客户端</li> <li><strong>Parallel Scavenge</strong>、<strong>Parallel Old</strong>：多线程收集器，适用于注重吞吐量以及 CPU 资源敏感的场合</li> <li><strong>ParNew</strong>：Serial 的多线程版本，适用于服务端，只有它能与 CMS 收集器配合工作</li> <li><strong>CMS</strong>：
<ul><li>全称 Concurrent Mark Sweep，标记-清除算法，用于老年代GC</li> <li>第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</li> <li>它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：
<ul><li>Step1 <strong>初始标记</strong>： <strong>暂停所有的其他线程</strong>，并记录下 GC Roots 能直接关联到的对象，速度很快；<em>(需要停顿)</em></li> <li>Step2 <strong>并发标记</strong>： <strong>同时开启 GC 和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方；<em>(不需要停顿)</em></li> <li>Step3 <strong>重新标记</strong>： 为了修正 Step2并发标记期间 因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录；<em>（需要停顿）</em></li> <li>Step4 <strong>并发清除</strong>： <strong>开启用户线程，同时 GC 线程开始</strong>对未标记的区域做清扫。<em>（不需要进行停顿）</em></li></ul></li> <li><strong>从 JDK9 开始，CMS 收集器已被弃用（G1 垃圾收集器成为了默认的垃圾收集器）</strong>。</li></ul></li> <li><strong>G1</strong>（下一个问题详细阐述）：JDK9之后默认使用G1，可以直接对新生代和老年代一起回收，复制算法</li></ul></div></div><h4 id="⚪-详细聊一下g1垃圾回收器❓"><a href="#⚪-详细聊一下g1垃圾回收器❓" class="header-anchor">#</a> ⚪ 详细聊一下G1垃圾回收器❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>JDK9之后默认使用G1，G1可以直接对新生代和老年代一起回收，采用复制算法。</p> <p>G1 把堆划分成多个大小相等的 <strong>独立区域(Region)</strong> ，新生代和老年代不再物理隔离，如图所示：</p> <p><img src="/blog/assets/img/image-7.002cf092.png" alt="alt text"></p> <p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。同时，每个小空间都可以充当 Eden，Survivor（s0,s1），Old， Humongous，其中 Humongous 专为大对象准备。</p> <p>G1 收集器通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，<strong>并在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p></div></div><h3 id="jvm-实践"><a href="#jvm-实践" class="header-anchor">#</a> JVM 实践</h3> <h4 id="⚪-jvm-调优的参数可以在哪里设置❓"><a href="#⚪-jvm-调优的参数可以在哪里设置❓" class="header-anchor">#</a> ⚪ JVM 调优的参数可以在哪里设置❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li><strong>方式1</strong>：Tomcat：war 包部署在 Tomcat 中设置</li></ol> <p>修改 <code>TOMCAT_HOME/bin/catalina.sh</code> 文件（针对Linux，Win下则是 <code>.bat</code> 后缀）</p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240528002527.png" alt="Linux下catalina.sh" class="zoom"> <ol start="2"><li><strong>方式2</strong>：Springboot：jar 包部署在启动参数设置</li></ol> <p>通常在 Linux 系统下直接加参数启动 Springboot 项目，命令：</p> <p><code>nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</code></p></div></div><h4 id="⚪-用的-jvm-调优的参数都有哪些❓"><a href="#⚪-用的-jvm-调优的参数都有哪些❓" class="header-anchor">#</a> ⚪ 用的 JVM 调优的参数都有哪些❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>官网所有的 JVM 调优参数：<a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html" target="_blank" rel="noopener noreferrer">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>列举一些比较常见的：</p> <ul><li>设置堆空间大小
<ul><li><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li> <li><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 最大大小的默认值是物理内存的1/4，初始大小是物理内存的1/64</span>
<span class="token operator">-</span><span class="token class-name">Xms1024</span>   <span class="token comment">// 不指定单位默认为字节</span>
<span class="token operator">-</span><span class="token class-name">Xms1024k</span>
<span class="token operator">-</span><span class="token class-name">Xms1024m</span>
<span class="token operator">-</span><span class="token class-name">Xms1g</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li>虚拟机栈的设置
<ul><li><code>-Xss</code>：每个线程的虚拟机栈的大小</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 每个线程默认会开启1M的内存</span>
<span class="token operator">-</span><span class="token class-name">Xss128k</span>  <span class="token comment">// 对每个线程 stack 大小的调整</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li>年轻代中Eden区和两个Survivor区的大小比例
<ul><li>默认比例为 Eden:s0:s1 = 8:1:1</li> <li><code>-XX:SurvivorRatio</code>：表示年轻代中的分配比例</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token class-name">SurvivorRatio</span><span class="token operator">=</span><span class="token number">8</span>    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li>年轻代晋升老年代阈值
<code>-XX:MaxTenuringThreshold</code>：年轻代晋升老年代阈值</li> <li>设置垃圾回收收集器
<ul><li><code>-XX:+UseParallelGC</code></li> <li><code>-XX:+UseParallelOldGC</code></li> <li><code>-XX:+UseG1GC</code></li></ul></li></ul></div></div><h4 id="⚪-说一下-jvm-调优的工具❓"><a href="#⚪-说一下-jvm-调优的工具❓" class="header-anchor">#</a> ⚪ 说一下 JVM 调优的工具❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ul><li>命令工具
<ul><li>jps          进程状态信息</li> <li>jstack     查看java进程内线程的堆栈信息</li> <li>jmap      查看堆转信息</li> <li>jhat       堆转储快照分析工具</li> <li>jstat      JVM统计监测工具</li></ul></li> <li>可视化工具
<ul><li>jconsole      用于对jvm的内存，线程，类 的监控（可以检测死锁）</li> <li>VisualVM    能够监控线程，内存情况</li></ul></li></ul></div></div><h4 id="⚪-java内存泄露的排查思路❓"><a href="#⚪-java内存泄露的排查思路❓" class="header-anchor">#</a> ⚪ Java内存泄露的排查思路❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><p>内存泄漏，指丢失了数据的地址，没法引用也没法删除。</p> <p><span style="color:rgb(122 116 116);">以下内容可能是内存溢出，而不是内存泄漏的排查思路</span></p> <img src="https://raw.githubusercontent.com/DishuZ/PicGo/main/all/20240528011040.png" alt="20240528011040" class="zoom"> <p>如图所示，JVM Stack 一般是递归循环造成的 <code>StackOverFlowError</code> 内存溢出；方法区一般是加载的类信息太多导致 <code>OutOfMemoryError:Metaspace</code> 内存不足；Heap 比较常见 <code>OutOfMemoryError:java heap space</code> 报错，面试官也比较关系这部分。</p> <p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况。</p> <p>排查思路：</p> <p>1、通过jmap或设置jvm参数获取堆内存快照dump
2、通过工具， VisualVM去分析dump文件，VisualVM可以加载离线的dump文件
3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题
4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p></div></div><h4 id="⚪-cpu飙高排查方案与思路❓"><a href="#⚪-cpu飙高排查方案与思路❓" class="header-anchor">#</a> ⚪ CPU飙高排查方案与思路❓</h4> <div class="zenbu-answer"><p class="zenbu-answer-title">🙋🏻‍♂️ 答：</p><div class="zenbu-answer-context"><ol><li>Step1：使用top命令查看占用cpu的情况</li> <li>Step2：通过top命令查看后，可以查看是哪一个进程占用cpu较高（确定Java程序的进程PID）</li> <li>Step3：使用ps命令查看进程中的线程信息（根据进程PID找到其中的每个线程PID，由哪个线程PID导致的CPU高占有率）</li> <li>Step4：使用jstack命令查看进程中哪些线程出现了问题，最终定位问题（根据线程PID，找到对应栈顶栈帧，定位代码行号）</li></ol> <p><strong>总结</strong>：<code>top</code> → <code>ps H -eo pid,tid,%cpu | grep &lt;pid&gt;</code>  → <code>jstack &lt;pid&gt;</code> → 找到对应nid  → 栈顶栈帧</p></div></div><h2 id="框架篇"><a href="#框架篇" class="header-anchor">#</a> 框架篇</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java/java_qa.html" class="prev">
        💬 面经
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.5cf145b8.js" defer></script><script src="/blog/assets/js/2.a59f6ee1.js" defer></script><script src="/blog/assets/js/4.c20dd059.js" defer></script>
  </body>
</html>
