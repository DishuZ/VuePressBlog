<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💬 面经 | Zenbu Space</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/assets/img/favicon.ico">
    <meta name="description" content="属于Zenbu的个人博客，持续记录对技术的讲解和梳理学习的知识">
    
    <link rel="preload" href="/blog/assets/css/0.styles.c2eac126.css" as="style"><link rel="preload" href="/blog/assets/js/app.5cf145b8.js" as="script"><link rel="preload" href="/blog/assets/js/2.a59f6ee1.js" as="script"><link rel="preload" href="/blog/assets/js/3.1fcfa166.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ebdacc7e.js"><link rel="prefetch" href="/blog/assets/js/11.5b92bcb6.js"><link rel="prefetch" href="/blog/assets/js/12.3775846d.js"><link rel="prefetch" href="/blog/assets/js/13.0d25ebcd.js"><link rel="prefetch" href="/blog/assets/js/14.ae1aacae.js"><link rel="prefetch" href="/blog/assets/js/15.96f13d95.js"><link rel="prefetch" href="/blog/assets/js/16.9d928f8a.js"><link rel="prefetch" href="/blog/assets/js/17.53415660.js"><link rel="prefetch" href="/blog/assets/js/18.a4bc894e.js"><link rel="prefetch" href="/blog/assets/js/19.8d81ed15.js"><link rel="prefetch" href="/blog/assets/js/20.26f2bfb0.js"><link rel="prefetch" href="/blog/assets/js/21.4502dce7.js"><link rel="prefetch" href="/blog/assets/js/22.8f5a25ef.js"><link rel="prefetch" href="/blog/assets/js/23.7c5c9567.js"><link rel="prefetch" href="/blog/assets/js/24.ca2c3768.js"><link rel="prefetch" href="/blog/assets/js/25.6d8bbb42.js"><link rel="prefetch" href="/blog/assets/js/26.83039fbb.js"><link rel="prefetch" href="/blog/assets/js/27.adf92751.js"><link rel="prefetch" href="/blog/assets/js/28.f2a024b0.js"><link rel="prefetch" href="/blog/assets/js/29.b3926ca2.js"><link rel="prefetch" href="/blog/assets/js/30.40311e72.js"><link rel="prefetch" href="/blog/assets/js/31.c606d6bc.js"><link rel="prefetch" href="/blog/assets/js/32.1a2b64e2.js"><link rel="prefetch" href="/blog/assets/js/33.c9197e3a.js"><link rel="prefetch" href="/blog/assets/js/34.cdcb1225.js"><link rel="prefetch" href="/blog/assets/js/35.dcf7bf36.js"><link rel="prefetch" href="/blog/assets/js/36.ee20ca71.js"><link rel="prefetch" href="/blog/assets/js/37.adc3728f.js"><link rel="prefetch" href="/blog/assets/js/38.b1a60eb1.js"><link rel="prefetch" href="/blog/assets/js/39.254937f1.js"><link rel="prefetch" href="/blog/assets/js/4.c20dd059.js"><link rel="prefetch" href="/blog/assets/js/40.78db51cb.js"><link rel="prefetch" href="/blog/assets/js/41.d9ca5bc7.js"><link rel="prefetch" href="/blog/assets/js/42.ea0a803d.js"><link rel="prefetch" href="/blog/assets/js/43.73b011a9.js"><link rel="prefetch" href="/blog/assets/js/44.bb4d0a8e.js"><link rel="prefetch" href="/blog/assets/js/45.5b12916f.js"><link rel="prefetch" href="/blog/assets/js/46.da1586e9.js"><link rel="prefetch" href="/blog/assets/js/47.d9436699.js"><link rel="prefetch" href="/blog/assets/js/48.0e0875ef.js"><link rel="prefetch" href="/blog/assets/js/49.f37da9a2.js"><link rel="prefetch" href="/blog/assets/js/5.923729f1.js"><link rel="prefetch" href="/blog/assets/js/50.e6807bb8.js"><link rel="prefetch" href="/blog/assets/js/51.279356c7.js"><link rel="prefetch" href="/blog/assets/js/52.42f15bb0.js"><link rel="prefetch" href="/blog/assets/js/53.c2ee570b.js"><link rel="prefetch" href="/blog/assets/js/54.b05f4789.js"><link rel="prefetch" href="/blog/assets/js/55.0dd0fd5d.js"><link rel="prefetch" href="/blog/assets/js/56.b21f6abc.js"><link rel="prefetch" href="/blog/assets/js/57.7a560703.js"><link rel="prefetch" href="/blog/assets/js/58.729a904b.js"><link rel="prefetch" href="/blog/assets/js/59.9fb40538.js"><link rel="prefetch" href="/blog/assets/js/6.fae665ef.js"><link rel="prefetch" href="/blog/assets/js/60.27a63915.js"><link rel="prefetch" href="/blog/assets/js/61.e309bf9f.js"><link rel="prefetch" href="/blog/assets/js/62.efb2b7de.js"><link rel="prefetch" href="/blog/assets/js/63.6a6d79d0.js"><link rel="prefetch" href="/blog/assets/js/64.12006acb.js"><link rel="prefetch" href="/blog/assets/js/65.8a1adaa8.js"><link rel="prefetch" href="/blog/assets/js/66.3c866e11.js"><link rel="prefetch" href="/blog/assets/js/7.39c6f4a0.js"><link rel="prefetch" href="/blog/assets/js/8.8113b657.js"><link rel="prefetch" href="/blog/assets/js/9.138ddabb.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.c2eac126.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container tech-page"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/img/logo.png" alt="Zenbu Space" class="logo"> <span class="site-name can-hide">Zenbu Space</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  🏠Home
</a></div><div class="nav-item"><a href="/blog/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><a href="/blog/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/blog/java/" class="nav-link router-link-active">
  ☕Java
</a></div><div class="nav-item"><a href="/blog/algorithm/leetcode100top.html" class="nav-link">
  💫算法
</a></div><div class="nav-item"><a href="/blog/mark_md.html" class="nav-link">
  Markdown
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Liberary Menu" class="dropdown-title"><span class="title">Liberary</span> <span class="arrow down"></span></button> <button type="button" aria-label="Liberary Menu" class="mobile-dropdown-title"><span class="title">Liberary</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/proletarian/" class="nav-link">
  阅读
</a></li><li class="dropdown-item"><!----> <a href="/blog/resource.html" class="nav-link">
  资源
</a></li></ul></div></div> <a href="https://github.com/DishuZ/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  🏠Home
</a></div><div class="nav-item"><a href="/blog/about.html" class="nav-link">
  About
</a></div><div class="nav-item"><a href="/blog/cpp/" class="nav-link">
  C++
</a></div><div class="nav-item"><a href="/blog/java/" class="nav-link router-link-active">
  ☕Java
</a></div><div class="nav-item"><a href="/blog/algorithm/leetcode100top.html" class="nav-link">
  💫算法
</a></div><div class="nav-item"><a href="/blog/mark_md.html" class="nav-link">
  Markdown
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Liberary Menu" class="dropdown-title"><span class="title">Liberary</span> <span class="arrow down"></span></button> <button type="button" aria-label="Liberary Menu" class="mobile-dropdown-title"><span class="title">Liberary</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/proletarian/" class="nav-link">
  阅读
</a></li><li class="dropdown-item"><!----> <a href="/blog/resource.html" class="nav-link">
  资源
</a></li></ul></div></div> <a href="https://github.com/DishuZ/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java技术文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/" aria-current="page" class="sidebar-link">🎮 基础知识</a></li><li><a href="/blog/java/basic/java_basic_x_annotation.html" class="sidebar-link">🎯 注解</a></li><li><a href="/blog/java/basic/java_basic_x_proxy.html" class="sidebar-link">👫 代理模式</a></li><li><a href="/blog/java/java_use.html" class="sidebar-link">⚙ 即用工具箱</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java解析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/java_collections.html" class="sidebar-link">📦 Collections</a></li><li><a href="/blog/java/jvm/java_jvm_classload.html" class="sidebar-link">类加载过程详解</a></li><li><a href="/blog/java/jvm/java_jvm_jmm.html" class="sidebar-link">JVM 内存模型</a></li><li><a href="/blog/java/jvm/java_jvm_struct.html" class="sidebar-link">JVM 内存结构</a></li><li><a href="/blog/java/java_qa.html" aria-current="page" class="active sidebar-link">💬 面经</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/java_qa.html#八股" class="sidebar-link">八股</a></li><li class="sidebar-sub-header"><a href="/blog/java/java_qa.html#面经" class="sidebar-link">面经</a></li></ul></li><li><a href="/blog/java/java_heima_mianshi.html" class="sidebar-link">Java面试总结</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="💬-面经"><a href="#💬-面经" class="header-anchor">#</a> 💬 面经</h1> <p></p><div class="table-of-contents-default"><div class="toc-container-header">文章目录</div><ul><li><a href="#八股">八股</a><ul><li><a href="#mysql">Mysql</a></li></ul></li><li><a href="#面经">面经</a><ul><li><a href="#饿了么-2024-04-10">饿了么 - 2024.04.10</a></li><li><a href="#阿里巴巴-2-2024-04-13">阿里巴巴（2） - 2024.04.13</a></li><li><a href="#滴滴一面-2024-04-16">滴滴一面 - 2024.04.16</a></li><li><a href="#滴滴二面-2024-04-18">滴滴二面 - 2024.04.18</a></li><li><a href="#字节跳动-2024-04-20">字节跳动 - 2024.04.20</a></li><li><a href="#腾讯qq-一面-2024-04-23">腾讯QQ（一面） - 2024.04.23</a></li><li><a href="#腾讯qq-二面-2024-04-25">腾讯QQ（二面） - 2024.04.25</a></li><li><a href="#海康威视-2024-05-19">海康威视 - 2024.05.19</a></li></ul></li></ul></div><p></p> <h2 id="八股"><a href="#八股" class="header-anchor">#</a> 八股</h2> <h3 id="mysql"><a href="#mysql" class="header-anchor">#</a> Mysql</h3> <details class="custom-block details"><summary>MySQL 的 NULL 值是怎么存放的？</summary> <p>🙋🏻‍♂️ 回答：</p> <p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p> <p>「NULL值列表」会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有「NULL值列表」 1 字节的空间。</p> <p>🎯 要点：</p> <ul><li>独占表空间文件 <code>*.ibd</code> <ul><li>表空间 (Tablespace) → 段 (Segment) → 区 (Extent) → 页 (Page, 16KB) → 行 (row)</li></ul></li> <li>Mysql 行格式
<ul><li>类型
<ul><li>Compact <em>（MySQL 5.1 版本之后，行格式默认设置成 Compact）</em></li> <li>Compressed</li> <li>Dynamic <em>（MySQL5.7 版本之后，默认使用 Dynamic 行格式）</em></li></ul></li> <li>Compact = 「变长字段长度列表」+「NULL值列表」+「记录头信息」+「真实数据」</li></ul></li></ul></details> <details class="custom-block details"><summary>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</summary> <p>🙋🏻‍♂️ 回答：</p> <p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p></details> <details class="custom-block details"><summary>varchar(n) 中 n 最大取值为多少？</summary> <p>🙋🏻‍♂️ 回答：</p> <p>我们需要在建表时根据表字段的数量和类型来计算 <code>n</code> 的最大取值。</p> <p>因为一行记录最大能存储 <code>65535</code> 字节的数据，这个是包含「变长字段字节数列表」和「NULL值列表」所占用的字节数。所以， 我们在算 <code>varchar(n)</code> 中 <code>n</code> 最大值时，需要减去这两个列表所占用的字节数。</p> <p><strong>假设</strong>，如果一张表只有一个 <code>varchar(n)</code> 字段，且允许为 <code>NULL</code> ，字符集为 <code>ascii</code>。<code>varchar(n)</code> 中 <code>n</code> 最大取值为 65532。</p> <p>计算公式：<code>65535 - 「变长字段字节数列表」所占用的字节数 - 「NULL值列表」所占用的字节数 = 65535 - 2 - 1 = 65532</code>。</p> <p>如果有多个字段的话，要保证 <code>所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 ≤ 65535</code>。</p></details> <details class="custom-block details"><summary>行溢出后，MySQL 是怎么处理的？</summary> <p>🙋🏻‍♂️ 回答：</p> <p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p> <ul><li>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 <strong>20 字节</strong> 存储指向溢出页的地址，从而可以找到剩余数据所在的页。
<img src="https://raw.gitmirror.com/DishuZ/PicGo/main/all/20240331235618.png" alt="Compact 行格式针对行溢出的处理" class="zoom"></li> <li>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。
<img src="https://raw.gitmirror.com/DishuZ/PicGo/main/all/20240331235554.png" alt="Compressed 和 Dynamicd的完全行溢出方式" class="zoom"></li></ul></details> <details class="custom-block details"><summary>事务的隔离级别有哪些？</summary> <p>🙋🏻‍♂️ 回答：</p> <p>SQL 标准提出了<strong>四种隔离级别</strong>来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p> <ul><li><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li> <li><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li> <li><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li> <li><strong>串行化（serializable ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul> <p>这四种隔离级别是用来规避并发事务引发的问题 <em>（脏读、不可重复读、幻读）</em> 的，针对不同隔离级别，并发事务时可能发生的现象也会不同。</p> <img src="https://raw.gitmirror.com/DishuZ/PicGo/main/all/20240409153155.png" alt="针对不同隔离级别，并发事务时可能发生的现象也会不同" class="zoom"> <p>如上图所示：</p> <ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li> <li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li> <li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li> <li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul></details> <details class="custom-block details"><summary>MySQL事务的实现原理是什么？</summary> <p>🙋🏻‍♂️ 回答：</p> <p>MySQL事务的实现原理，包括事务的ACID特性、MVCC机制、行锁和表锁的使用、undo log和radio log的作用等。通过保证原子性、一致性、隔离性和持久性，实现了事务的正确性和数据的一致性。视频还提到了一些设计思想，如利用内存缓冲区的方式优化磁盘I0性能等。对于准备面试的同学来说，这个视频提供了很好的参考和学习资源。</p> <p>来源：https://www.bilibili.com/video/BV1am421L7Co</p></details> <h2 id="面经"><a href="#面经" class="header-anchor">#</a> 面经</h2> <h3 id="饿了么-2024-04-10"><a href="#饿了么-2024-04-10" class="header-anchor">#</a> 饿了么 - 2024.04.10</h3> <details class="custom-block details"><summary>说说 OAuthn2 ？</summary> <p>OAuth2 → Open Authorization 网络授权开放标准，允许三方系统在不使用用户名和密码的情况下，访问另一个服务的资源。</p> <p>OAuth2 组成：</p> <ol><li>用户</li> <li>用户代理（浏览器）</li> <li>授权服务器（如百度）</li> <li>资源服务器</li></ol> <p>OAuth2 模式：</p> <ol><li><strong>授权码模式</strong> <ol><li>用户 → 用户代理 → 三方应用（微信扫描登录）</li> <li>三方应用 → 授权服务器 → 授权页面</li> <li>用户点击“确认授权” → 三方授权服务器拿到<strong>授权码</strong></li> <li>三方应用根据授权码 → 授权服务器 → 得到用户登录的 <strong>Token（用户令牌）</strong></li> <li>三方应用根据 Token 去资源服务器拉取资源。</li> <li>资源服务器验证 Token 真伪，将资源给三方服务器。</li></ol></li> <li><strong>简单模式</strong>：简化授权码模式，用户确认授权之后，直接获取到 Token（而不是先获取授权码，再获取 Token）。</li> <li><strong>密码模式</strong>：用户高度信任三方平台，将资源服务器的用户名和密码存储在三方平台，然后由三方平台根据用户名和密码访问资源服务器，获取资源。</li> <li><strong>客户端模式</strong>：三方系统直接和资源服务器进行通讯。</li></ol></details> <details class="custom-block details"><summary>说说 JWT ？</summary> <p>JWT → JSON Web Token 开放流程定义的方式，用于网络之间安全地传输信息，例如用户验证、授权、信息交换等。</p> <p>JWT 组成：</p> <ol><li>Header → 存储加密算法</li> <li>Payload（负载信息） → 用户信息</li> <li>Signature（签名） → 加密字符（效验 Token 有效性）</li></ol> <p>JWT 流程：</p> <ol><li>用户将用户名和密码传到后台服务器；</li> <li>后台服务器验证用户名和密码 → JWT 算法生成 Token （包含上述3部分内容） → 发送给前端</li> <li>前端将 JWT Token 以 Header 的形式传递给后端</li> <li>后端拿到 JWT Token 进行效验：加密算法 + JWT 服务器私钥 + Payload = 生成 Signature。如果 生成的 Signature 与 JWT Token Signature 相等，说明这是一个有效的登录（用户信息 Payload）</li></ol> <p>注：JWT 用于企业内部，OAuth 用于外部系统的互相调用</p></details> <details class="custom-block details"><summary>创建订单前流程？</summary> <p>创建订单前流程：</p> <ol><li>幂等性问题</li> <li>效验用户权限（用户有没有登录）</li> <li>用户是否支付（购买订单）</li> <li>库存是否足够</li> <li>其他信息判断（如：配送信息等）</li></ol></details> <h3 id="阿里巴巴-2-2024-04-13"><a href="#阿里巴巴-2-2024-04-13" class="header-anchor">#</a> 阿里巴巴（2） - 2024.04.13</h3> <details class="custom-block details"><summary>你知道跳表吗？</summary> <p>知道。
挑拨（跳跃表 SkipList）最常用的场景是 Redis 里面 ZSet 的底层实现。
跳表本质为多个链表。</p></details> <details class="custom-block details"><summary>Redis 基本数据结构有了解吗</summary> <p>Redis 五大基本数据结构：</p> <ul><li>String -&gt; 简单动态字符串</li> <li>Hash -&gt; 哈希表</li> <li>List -&gt; 双向链表</li> <li>Set -&gt; 哈希表 + 数组</li> <li>ZSet -&gt; 压缩表（ZipList） / 紧凑列表（ListPack） + 跳跃表（SkipList）</li></ul></details> <details class="custom-block details"><summary>你介绍一下 MVCC ？</summary> <p>MVCC 多版本并发控制 -&gt; 为 Mysql <strong>快照读</strong> 提供数据以及一套规则来让事务实现可重复读和解决大部分幻读（快照读的幻读问题）</p> <p>MVCC 核心原理：</p> <ol><li>undo log（表数据 + <code>trx_id</code> + 下一版数据指针）：数据的历史版本</li> <li>ReadView</li></ol> <p>参考：</p> <ul><li><a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener noreferrer">MySQL 可重复读隔离级别，完全解决幻读了吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.xiaolincoding.com/mysql/lock/lock_phantom.html" target="_blank" rel="noopener noreferrer">MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>说说 Spring 中的 IoC？</summary> <p>IoC -&gt; （对象）控制（权）反转。
IoC 实现 -&gt; DI, 依赖注入。
IoC 原理：反射机制（在程序运行期间，动态地获取和操作类的机制）</p></details> <details class="custom-block details"><summary>说说 Spring 中的 AOP？</summary> <p>回答思路：定义、使用、作用、底层实现</p> <p>定义：AOP 面向切面编程 -&gt; 将某一类问题集中处理。
AOP 实现/使用：</p> <ul><li>Step1. 添加AOP依赖。</li> <li>Step2. 定义切面 -&gt; <code>@Aspect</code></li> <li>Step3. 定义切点（配置拦截规则） -&gt; <code>Pointcut</code></li> <li>Step1. 定义执行动作 -&gt; <code>Advice</code> 前置通知/后置通知/环绕通知</li></ul> <p>Spring 原理：动态代理</p> <ol><li>JDK Proxy</li> <li>CGLib （SpringBoot 默认用）</li></ol></details> <details class="custom-block details"><summary>说说 SpringBoot 自动配置原理？</summary> <p>SpringBoot 自动装配流程：</p> <ol><li>运行添加 <code>@SpringBootApplication</code> 类，<code>main</code> 方法</li> <li>加载自动装配地类清单：SpringBoot jar <code>spring.factories</code> 文件</li> <li>查看自动装配类地装配条件：<code>@Configuration</code> + <code>@Condition</code></li></ol></details> <details class="custom-block details"><summary>RPC 了解吗？</summary> <p>RPC 远程过程调用：像调用本地方法一样来调用远程方法机制。</p> <p>RPC 特点：</p> <ol><li>执行高效（偏底层，自定义协议，对数据进行压缩...）</li> <li>跨平台（win 调用 linux ...）</li> <li>跨语言</li></ol> <p>RPC 使用场景：</p> <ol><li>分布式系统调用</li> <li>微服务之间的调用</li> <li>云计算（RPC 实现客户端和云服务器之间的调用）</li></ol></details> <details class="custom-block details"><summary>说说拥塞控制？</summary> <p>拥塞控制是 TCP 特性之一，保证 TCP 在高负载网络环境下，数据可以平台传输的一种机制。</p> <blockquote><p>简单来说，拥塞控制根据当前网络情况，决定发送消息的速度的一种机制。</p></blockquote> <p>拥塞控制的实现：</p> <ol><li>慢启动</li> <li>拥塞控制（门限值）</li> <li>快重试</li> <li>快恢复</li></ol></details> <details class="custom-block details"><summary>我看你在项目中使用了 RabbitMQ，那你知道什么情况下会使用消息中间件呢？</summary> <p>RabbitMQ 使用场景：</p> <ol><li>解耦系统</li> <li>异步通信</li> <li>削峰填谷（消费者按照我定义的速度均匀消费）</li> <li>大数据下的日志处理</li> <li>消息通知和广播</li></ol></details> <details class="custom-block details"><summary>RabbitMQ 如何避免消息丢失？</summary> <p>RabbitMQ 避免消息丢失：</p> <ol><li>持久化</li> <li>集群部署</li> <li>消息确认
<ol><li>生产者消息确认</li> <li>消费者消息确认</li></ol></li></ol></details> <details class="custom-block details"><summary>平时有用过一些设计模式吗？</summary> <p>常见的设计模式：</p> <ol><li>单例模式：Spring/SpringBoot-Bean</li> <li>工厂模式：线程池使用线程共产创建</li> <li>代理模式：Spring AOP</li> <li>发布-订阅模式：MQ</li> <li>观察者模式：Spring Event</li> <li>策略模式：支付渠道（微信/支付宝/...）</li> <li>责任链模式：拦截器链/过滤器链（参数效验、登录状态效验、权限效验、...）</li> <li>门面模式/适配器模式：我们只操作 <code>slf4j</code> -&gt; <code>slf4j</code> 对接操作 <code>log4j</code>、<code>logback</code>。前者是门面，后者是适配器</li></ol></details> <details class="custom-block details"><summary>怎么样进行性能优化？</summary> <p>常见优化手段：</p> <ol><li>程序优化
<ol><li>并发编程</li> <li>单例模式（不要重复创建）</li></ol></li> <li>数据库优化
<ol><li>优化索引使用</li> <li>Mysql 集群模式
<ol><li>主从默认</li> <li>数据分片模式 -&gt; 分库分表</li></ol></li> <li>使用大数据数据库，TiDB</li></ol></li> <li>架构优化
<ol><li>单机 -&gt; 分布式/微服务</li></ol></li> <li>JVM 优化
<ol><li>JVM 参数优化（堆多大、元空间多大、...）</li> <li>JVM 垃圾收集器的选择</li></ol></li> <li>使用多级缓存
<ol><li>本地缓存</li> <li>分布式缓存</li> <li>浏览器缓存</li> <li>CDN 缓存</li> <li>Nginx 缓存</li></ol></li> <li>其他优化：
<ol><li>硬件优化</li> <li>网络优化</li> <li>程序异步处理</li></ol></li></ol></details> <details class="custom-block details"><summary>你觉得 java 未来的就业前景怎么样？</summary> <p>AI加持、需求是否更改、...</p> <p>思路：</p> <ol><li>独立思考、讲现状</li> <li>积极的</li> <li>开放心态</li> <li>拥抱变化的心态</li> <li>展现热爱技术的特质</li></ol></details> <h3 id="滴滴一面-2024-04-16"><a href="#滴滴一面-2024-04-16" class="header-anchor">#</a> 滴滴一面 - 2024.04.16</h3> <details class="custom-block details"><summary>4. 说说 TCP 为什么需要四次挥手？</summary></details> <details class="custom-block details"><summary>5.</summary></details> <h3 id="滴滴二面-2024-04-18"><a href="#滴滴二面-2024-04-18" class="header-anchor">#</a> 滴滴二面 - 2024.04.18</h3> <details class="custom-block details"><summary>1. 介绍一下 MySQL 的索引</summary></details> <details class="custom-block details"><summary>2. 联合索引(a,b,c)使用 b&gt;=xxx and a = x 会使用联合索引吗？</summary></details> <details class="custom-block details"><summary>3. 介绍一下 MySQL 的日志</summary></details> <details class="custom-block details"><summary>4. redo log 怎么保持持久性？</summary></details> <details class="custom-block details"><summary>6. 能不能只用 bin log 不用 redo log？</summary> <p>不能，bin log 是用于数据传输，持久化是主库的操作，一个日志不能表示两种状态</p></details> <details class="custom-block details"><summary>7. 说说事务的ACID特性</summary> <p>一致性：事务会从一个一致状态，变为另一个一致状态</p></details> <details class="custom-block details"><summary>8. 四个事务隔离级别</summary></details> <details class="custom-block details"><summary>9. 可重复读是怎么实现的？</summary> <p>可重复读是由 MVCC 实现。MVCC 机制会给每个事务分配一个事务ID，并未每条数据记录保存它所属的事务版本信息</p></details> <details class="custom-block details"><summary>10. 介绍一下 MVCC 原理</summary> <blockquote><p>MVCC 解决 <strong>不可重复读问题</strong> 和 <strong>大部分幻读问题</strong>（可重复读级别下的当前读）</p></blockquote> <p>MVCC 原理：</p> <ol><li>undo log 链：历史数据，TRX_ID（操作此条数据时的id），下一条数据的引用</li> <li>ReadView：create_trx_id（创建事务时的id）、min_trx_id（最小的事务id）、max_trx_id（最大的事务id）、m_ids（所有活跃事务的id）</li></ol> <p>MVCC ReadView 对比执行流程：</p> <ol><li>create_trx_id == TRX_ID  -&gt; 当前事务的操作，直接查询到当前的这条信息</li> <li>TRX_ID &lt; min_trx_id  -&gt; 早期数据，直接查询到当前的这条信息</li> <li>TRX_ID &gt; max_trx_id  -&gt; 最新数据，看不到</li> <li>min_trx_id &lt; TRX_ID &lt; max_trx_id（执行中）：
<ul><li>TRX_ID 在 m_ids：TRX_ID的事务正在执行中（事务还没提交），看不到</li> <li>TRX_ID 不在 m_ids：TRX_ID的事务执行完了，能看到</li></ul></li></ol></details> <details class="custom-block details"><summary>11. 介绍一下 MySQL 中的锁</summary> <p>MySQL 锁：</p> <ol><li>全局锁：所有数据库加锁（适用场景：全库备份）</li> <li>表级锁</li> <li>行级锁</li> <li>表锁和行锁之间的锁：
<ul><li>间隙锁</li> <li>临建锁</li> <li>意向锁</li></ul></li></ol> <p>特征分类：</p> <ol><li>独占锁：select for update</li> <li>共享锁：lock in share mode  （写写、写读加锁，读读不加锁）</li></ol></details> <details class="custom-block details"><summary>12. 如果有一个字段的值是0或者1，适合建索引吗？</summary> <p>不适合。当记录只有0或1的时候就相当于全表扫描</p></details> <details class="custom-block details"><summary>13. 讲一下 SQL 优化方法</summary> <p>MySQL 优化的方法：</p> <ol><li>正确使用 SQL（占用更小的带宽，传输性能更高，可能会触发索引覆盖）</li> <li>正确创建和使用索引</li> <li>使用正确的字段类型（建表时，评估字段该用什么类型保存最合适）</li> <li>使用 MySQL 集群：
<ul><li>主从同步</li> <li>分库分表</li></ul></li> <li>分布式数据库，例如 TiDB</li></ol></details> <details class="custom-block details"><summary>14. 如何解决深度分页的问题？</summary> <p>深度分页问题：指的是查询的数据位于数据库的尾部，导致查询很慢的问题。</p> <p>深度分页的解决方案：</p> <ol><li>创建索引，最好能实现索引覆盖</li> <li>应用层添加缓存+数据预处理（数据预热）</li> <li>优化 MySQL 框架：使用读写分离</li> <li>将数据存储到 NoSQL 中（数据冗余）：es/mongodb高效地提升深度分页效率</li></ol> <blockquote><p>MySQL 数据库同步 NoSQL：监控 bin log 日志 -&gt; 通过阿里巴巴提供的 Canal 将数据同步到 -&gt; es/mongodb</p></blockquote></details> <details class="custom-block details"><summary>15. Redis 的 ZSet 底层是怎么实现的？</summary> <p>ZSet底层实现：</p> <ol><li>Redis 7.0 之前：ziplist（压缩列表）+ SkipList（跳跃表）</li> <li>Redis 7.0+ ：listpack（紧凑列表） + SkipList（跳跃表）</li></ol></details> <details class="custom-block details"><summary>16. 手撕算法：在旋转排序数组中找一个数</summary> <p>原题：https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked</p></details> <h3 id="字节跳动-2024-04-20"><a href="#字节跳动-2024-04-20" class="header-anchor">#</a> 字节跳动 - 2024.04.20</h3> <details class="custom-block details"><summary>1. 浏览器键入网址后的执行流程</summary></details> <details class="custom-block details"><summary>2. HTTP为什么是无状态的？</summary></details> <details class="custom-block details"><summary>3. synchronized 是怎么实现可重入的？</summary> <p>1️⃣ 答：</p> <p><code>synchronized</code> 可重入原理是通过 <strong>JVM 内部维护一个锁对象（锁）的计数器</strong>来实现的。</p> <p>首先，<strong>可重入性是针对同一个线程（锁程）多次获取同一把「锁对象」的情况</strong>。每个「锁对象」都有一个关联的 monitor（监视器），monitor 里包含了一个计数器。</p> <p>当线程尝试进入 <code>synchronized</code> 修饰的同步代码块/方法/..时，会先去查看 <code>synchronized</code> 「锁对象」的计数器：</p> <ol><li>情况1：如果计数器为 0，表示无锁。
<ul><li>当线程会立即获取到「锁对象」，也与对应的 monitor 和计数器产生关联，计数器 + 1；</li> <li>其他线程不能再获取「锁对象」，进入同步队列（SynchronizedQueue）等待。</li></ul></li> <li>情况2：如果计数器不为 0，并且该线程已经关联了该「锁对象」的 monitor，说明已经拿到了锁对象的所有权。
<ul><li>则表示该线程重入了这把锁，计数器 +1；</li> <li>随着重入的次数，计数器一直累加。</li> <li>相反的，退出同步代码块时，计数器 -1，直到计数器为 0 时，表示该线程释放了锁。</li></ul></li> <li>情况3：如果计数器不为 0，而该线程并没有关联 monitor，说明锁被别的线程持有，该线程需要等待锁的释放。</li></ol> <p>2️⃣ 总结</p> <p>总的来说，可重入原理是通过 JVM 内部维护一个锁对象（锁）的计数器来实现的。当线程重复获取同一把锁时，计数器会相应增加 1；当线程释放锁时，计数器会相应减少 1。只有当计数器为 0 时，锁才会被真正释放，从而允许其他线程获取该锁。这种机制确保了线程安全，并提高了程序的并发性能。</p> <p>3️⃣ 更底层</p> <blockquote><p><code>synchronized</code> 更底层的关于可重入的实现，是 C++ （JVM 底层通过 C++ 实现） 通过 <code>ObjectMonitor</code> 实现了 <code>synchronized</code>， <code>ObjectMonitor</code> 用 <code>_count</code> 字段（计数器）来实现可重入。</p></blockquote></details> <details class="custom-block details"><summary>4. Mysql 索引的底层实现？</summary> <p>注意：在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，最常用的存储引擎有 MyISAM 和 InnoDB。</p> <p>一般情况下，我们说的 Mysql 的存储引擎默认是 InnoDB（InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎），<strong>在后续存储引擎都指代为 InnoDB</strong>。</p> <p>1️⃣ 答：</p> <p>Mysql 索引底层是通过「B+ 树」来实现。</p> <p>2️⃣ 细节</p> <p>在数据库中，<strong>「索引」的定义，就是帮助存储引擎快速获取/查询「数据」的一种数据结构</strong>，形象的说就是“<strong>索引是数据的目录</strong>”。</p> <p>所谓的存储引擎，说白了就是如何 存储数据、如何 为存储的数据建立索引 和 如何更新、查询数据 等技术的实现方法。</p> <p>找到数据对应的索引，基本上相当于找到数据，所以 <em>如何快速索引</em> 成为了一个问题，Mysql 中通过「B+ 树」来建立索引，从而形成 B+ 索引树。</p> <p>从物理存储的角度来看，索引分为：</p> <ol><li>聚簇索引（主键索引）：聚簇索引「B+ 树」的叶子节点存放的是实际数据，所有<strong>完整的用户记录都存放在聚簇索引的「B+ 树」的叶子节点里</strong></li> <li>二级索引（辅助索引）：二级索引「B+ 树」的<strong>叶子节点存放的是主键值</strong>，而不是实际数据。
<ul><li>如果在查询时使用了二级索引，并且查询的数据能在二级索引里直接查询到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>；</li> <li>如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后通过主键值再检索聚簇索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</li></ul></li></ol> <p>在创建表时，存储引擎默认会创建一个主键索引，也就是聚簇索引，其它索引都属于二级索引。</p> <p>3️⃣ 扩展问题</p> <ul><li>MySQL 索引：索引为什么使用 B+树？<a href="https://www.cnblogs.com/kismetv/p/11582214.html" target="_blank" rel="noopener noreferrer">答案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>从最普通的二叉查找树开始，逐步说明各种树解决的问题以及面临的新问题，从而说明 MySQL 为什么选择 B+ 树 作为索引结构</li></ul></li> <li>MySQL 索引：索引失效有哪些情况？<a href="https://www.xiaolincoding.com/mysql/index/index_lose.html" target="_blank" rel="noopener noreferrer">答案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>对索引使用左 <code>like %xx</code> 或左右 <code>like %xx%</code> 模糊匹配</li> <li>对索引使用函数</li> <li>对索引进行表达式计算</li> <li>对索引隐式类型转换（索引字段是字符串，输入是数字时失效，因为 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字）</li> <li>联合索引非最左匹配</li> <li><code>WHERE</code> 子句中的 <code>OR</code>（如果在 <code>OR</code> 前的条件列是索引列，而在 <code>OR</code> 后的条件列不是索引列，那么索引会失效）</li></ul></li> <li>MySQL 索引：有什么优化索引的方法？<a href="https://www.xiaolincoding.com/mysql/index/index_interview.html#%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">答案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <ul><li>前缀索引优化；</li> <li>覆盖索引优化；</li> <li>主键索引最好是自增的；</li> <li>防止索引失效；</li></ul></li></ul></details> <details class="custom-block details"><summary>5. Mysql 如何保证原子性？</summary> <p>把问题转换为：Mysql Innodb 存储引擎层事务的原子性。</p> <p>1️⃣ 答：</p> <p>通过 <code>undo log</code> 日志来保证「事务」的原子性。</p> <p><code>undo log</code> 是一种用于撤销回退的日志，称为「回滚日志」。</p> <ul><li><strong>在「事务」没提交之前</strong>，每当 InnoDB 引擎对一条「记录」进行操作（修改、删除、新增）时，会把回滚时需要的信息都记到 <code>undo log</code> 里；</li> <li><strong>当「事务」回滚时</strong>，可以利用 <code>undo log</code> 来进行回滚。简单来说，就是读取 <code>undo log</code> 里的数据，然后做原先相反操作。</li></ul> <p>比如：</p> <ul><li>在<strong>插入</strong>一条「记录」时，要把这条「记录」的主键值记下来，这样之后回滚时只需要把这个主键值对应的「记录」删掉就好了；</li> <li>在<strong>删除</strong>一条「记录」时，要把这条「记录」中的内容都记下来，这样之后回滚时再把由这些内容组成的「记录」插入到表中就好了；</li> <li>在<strong>更新</strong>一条「记录」时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。</li></ul> <p>2️⃣ 细节</p> <p>事务（Transaction）的四个特性（ACID）：</p> <ol><li><strong>原子性（Atomicity）</strong>：<strong>一个事务中</strong>的所有操作，要么全部完成，要么全部不完成</li> <li><strong>一致性（Consistency）</strong>：是指<strong>事务操作前和操作后</strong>，数据满足<strong>完整性约束</strong>，<strong>数据库保持一致性</strong>状态</li> <li><strong>隔离性（Isolation）</strong>：隔离性可以防止<strong>多个事务并发执行时</strong>由于交叉执行而导致数据的不一致</li> <li><strong>持久性（Durability）</strong>：事务处理结束后，<strong>对数据的修改就是永久的</strong>，即便系统故障也不会丢失</li></ol> <p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p> <ol><li>原子性是通过 <code>undo log</code>（回滚日志） 来保证的；</li> <li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li> <li>持久性是通过 <code>redo log</code> （重做日志）来保证的；</li> <li>一致性则是通过持久性+原子性+隔离性来保证；</li></ol></details> <details class="custom-block details"><summary>6. 事务的隔离级别有哪些？</summary> <p>一般在 Java 中，使用最多的就是 Mysql 数据库，所以这里就回答 Mysql 事务的隔离级别。（必须有这个前提，因为每个数据库的事务隔离级别不一样）。</p> <p>1️⃣ 答：</p> <p>MySQL 事务用四种隔离级别来规避「脏读、不可重复读、幻读」现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p> <ol><li><strong>读未提交（read uncommitted）</strong>：允许事务<strong>读取到其他事务尚未提交的数据</strong>。存在「脏读、不可重复读、幻读」问题。</li> <li><strong>读已提交（read committed）</strong>：要求当前事务<strong>只能读取到其他事务已提交的数据</strong>。不存在「脏读」问题，但存在「不可重复读、幻读」问题。</li> <li><strong>可重复读（repeatable read）</strong>：一旦事务开始读取数据，读取的数据跟这个事务启动时看到的数据都是一致的。不存在「不可重复读」问题，但<strong>可能存在</strong>「幻读」问题。<em>(「可重复读」是 Mysql 默认的事务隔离级别)</em> 。</li> <li><strong>串行化（serializable ）</strong>：它是最高的隔离级别，每个时刻最多只有一个事务在执行，即排队执行。不存在「脏读、不可重复读、幻读」问题。<em>（但是串行化的执行效率低，一般不会设置成该隔离级别）</em></li></ol> <p>四个隔离级别下存在的问题如下图所示：</p> <p><img src="/blog/assets/img/image.1804b2b2.png" alt="针对不同的隔离级别，并发事务时可能发生的现象也会不同"></p> <p>⚠ 注意，在 SQL 标准的「可重复读」隔离级别下，是存在「幻读」问题的。<strong>但在 MySQL 的「可重复读」隔离级别下，可以很大程度上避免「幻读」现象的发生</strong>，解决「幻读」的方案有两种：</p> <ul><li>针对<strong>快照读</strong>（普通 <code>select</code> 语句），是通过 MVCC（多版本并发控制，通过 Read View + <code>undo log</code> 实现） 方式解决了「幻读」</li> <li>针对<strong>当前读</strong>（<code>select ... for update</code> 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了「幻读」</li></ul> <p>2️⃣ 扩展问题</p> <p>首先，在 Mysql 中，只有 InnoDB 引擎支持「事务」。</p> <p><strong>1. 「事务」为什么会有隔离级别？</strong></p> <p>引入「事务」隔离级别的主要原因是，确保并发执行的「事务」之间的隔离性（Isolation）和一致性（Consistency）。在 Mysql 中，多个「事务」可能会同时运行并尝试访问或修改相同的数据。如果没有适当的隔离机制，<strong>在同时处理多个并发「事务」的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p> <hr> <p><strong>2. 并行「事务」会引发什么问题？</strong></p> <p>1）脏读（dirty read）</p> <p>如果<strong>一个事务读到了另一个未提交事务</strong>修改过的数据 ，就意味着发生了「脏读」现象。</p> <blockquote><p>举个栗子🌰：</p> <p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p> <p>因为事务 A 还没提交事务，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为「脏读」</strong>。</p></blockquote> <p>2）不可重复读（non-repeatable read）</p> <p><strong>在一个事务内</strong>多次读取同一个数据，如果出现前后<strong>两次读到的数据不一样</strong>的情况，就意味着发生了「不可重复读」现象。</p> <blockquote><p>举个栗子🌰：</p> <p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为「不可重复读」</strong>。</p></blockquote> <p>3）幻读（phantom read）</p> <p><strong>在一个事务内</strong>多次查询某个符合查询条件的记录数量，如果出现（同样的条件下）<strong>前后两次查询到的记录数量不一样</strong>的情况，就意味着发生了「幻读」现象。</p> <blockquote><p>举个栗子🌰：</p> <p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p> <p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p> <p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为「幻读」</strong>。</p></blockquote> <hr> <p><strong>3. 四种隔离级别具体是如何实现的？</strong></p> <ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li> <li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li> <li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。
<ul><li>「读提交」隔离级别是<strong>在每个语句执行前都会重新生成</strong>一个 Read View，</li> <li>「可重复读」隔离级别是<strong>启动「事务」时生成</strong>一个 Read View，然后整个事务期间都在用这个 Read View。</li></ul></li></ul> <p>更详细查看文章：<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html" target="_blank" rel="noopener noreferrer">事务隔离级别是怎么实现的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details> <details class="custom-block details"><summary>7. 「读未提交」的底层原理？</summary> <p>1️⃣ 答：</p> <p>读未提交（Read Uncommitted），采取的是“读不加锁、写加锁”：</p> <ul><li>事务读不加锁，不阻塞其他事务的读和写</li> <li>事务写阻塞其他事务写，但不阻塞其他事务读</li></ul> <blockquote><p>SELECT statements（读取语句） are performed in a nonlocking fashion, but a possible earlier version of a row might be used. Thus, using this isolation level, such reads are not consistent. This is also called a dirty read（脏读）. Otherwise, this isolation level works like READ COMMITTED（读已提交）.</p> <p>—— 官方文档</p></blockquote> <p>参考：</p> <ul><li><a href="https://blog.csdn.net/u011397981/article/details/130387350" target="_blank" rel="noopener noreferrer">【数据库】事务的隔离级别以及实现原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener noreferrer">MySQL 8.0 Reference Manual<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>8. 说说 Redis 数据类型有哪些？</summary> <p>1️⃣ 答：</p> <p>常用的5种数据类型：</p> <table><thead><tr><th>数据类型</th> <th>数据结构</th> <th>应用场景</th></tr></thead> <tbody><tr><td><strong>String</strong></td> <td>SDS（简单动态字符串）</td> <td>• 缓存对象 <br> • 常规计数 <br> • 分布式锁 <br> • 共享session信息</td></tr> <tr><td><strong>List</strong></td> <td>• (Redis3.0) 双向链表 or 压缩列表 <br> • (Redis3.2+) quicklist</td> <td>• 消息队列（但有两个问题：1.生产者需要自行实现全局唯一 ID；2.不能以消费组形式消费数据）</td></tr> <tr><td><strong>Hash</strong></td> <td>• (Redis3.0) 哈希表 or 压缩列表 <br> • (Redis7.0+) 哈希表 or listpack</td> <td>• 缓存对象 <br> • 购物车</td></tr> <tr><td><strong>Set</strong></td> <td>• (Redis3.0) 哈希表 or 整数集合</td> <td>• 聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等</td></tr> <tr><td><strong>ZSet</strong></td> <td>• (Redis3.0) 跳表 or 压缩列表 <br> • (Redis7.0+) 跳表 or listpack</td> <td>• 排序场景，比如排行榜、电话和姓名排序等</td></tr></tbody></table> <p>其数据类型与底层数据结构的关系如图：</p> <p><img src="/blog/assets/img/image-14.63ef0190.png" alt="alt text"></p> <p>随便版本的更新，新增了4种数据类型：</p> <table><thead><tr><th>数据类型</th> <th>数据结构</th> <th>应用场景</th></tr></thead> <tbody><tr><td>BitMap <br>（Redis 2.2新增）</td> <td>String类型（二进制的字节数组）</td> <td>• 二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等</td></tr> <tr><td>HyperLogLog <br>（Redis 2.8新增）</td> <td></td> <td>• 海量数据基数统计的场景，比如百万级网页 UV 计数等</td></tr> <tr><td>GEO <br>（Redis 3.2新增）</td> <td>Sorted Set</td> <td>• 存储地理位置信息的场景，比如滴滴叫车</td></tr> <tr><td>Stream <br>（Redis 5.0新增）</td> <td></td> <td>• 消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据</td></tr></tbody></table> <p>参考：</p> <ul><li><a href="https://www.xiaolincoding.com/redis/data_struct/command.html" target="_blank" rel="noopener noreferrer">小林Coding|Redis常见数据类型和应用常见<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>9. 说说 Redis 中 ZSet 的底层实现</summary> <p>1️⃣ 答：</p> <p>Zset 类型的底层数据结构是由 <strong>压缩列表</strong>/<strong>listpack</strong> 或 <strong>跳表</strong> 实现：</p> <ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；
<ul><li><strong>注：</strong> 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li></ul></li> <li>如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；</li></ul> <p>三种数据结构：</p> <ul><li><strong>跳表</strong>：跳表是在链表的基础上改进过来的，相当于一种<strong>多层</strong>的<strong>有序</strong>链表，这样的好处是能快读定位数据。</li> <li><strong>压缩列表</strong>：压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。
<img src="/blog/assets/img/image-15.29545297.png" alt="alt text"></li> <li><strong>listpack</strong>：采用了压缩列表的很多优秀的设计，还是用一块连续的内存空间来紧凑地保存数据。与压缩列表对比，listpack没有压缩列表中记录前一个节点长度的字段 <code>prevlen</code> 了，只记录当前节点的长度 <code>len</code>。（<code>prevlen</code> 有可能导致连锁更新问题）
<img src="/blog/assets/img/image-16.fe3915df.png" alt="alt text"></li></ul> <p>参考：</p> <ul><li><a href="https://www.xiaolincoding.com/redis/data_struct/data_struct.html" target="_blank" rel="noopener noreferrer">小林Coding|Redis数据结构<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>10. Redis 中用什么数据结构实现延迟消息队列？</summary> <p>⚠ 注意，延迟消息队列 和 消息队列 的实现完全不一样！</p> <p>1️⃣ 答：</p> <p>使用 ZSet 实现延迟消息队列，将延迟执行的时间存储在 ZSet 的分值（Score），使用一个线程一直循环扫描 ZSet 分值，如果当前时间大于等于 ZSet 分值，说明当前的任务要执行了。</p> <p>https://blog.csdn.net/liuerpeng1904/article/details/134204808</p></details> <details class="custom-block details"><summary>11. 说说 Redis 的 RDB 持久化策略</summary> <p>1️⃣ 答：</p> <p>（1）概念</p> <p>RDB 持久化策略， 全称 Redis DataBase，将 Redis 某一时刻的数据（<strong>快照/snapshot</strong>）保存到<strong>磁盘</strong>上，以二进制的方式存储于 <strong>RDB 日志文件</strong>中。</p> <p>（2）持久化触发方式</p> <ul><li><strong>手动触发</strong>：通过执行 <code>save</code> 或 <code>bgsave</code> 命令来触发：
<ul><li><code>save</code> 命令会在主线程执行生成 RDB 文件，会阻塞主线程；</li> <li><code>bgsave</code> 命令则会创建一个子进程来执行生成 RDB 文件，从而避免阻塞主进程。</li></ul></li> <li><strong>自动触发</strong>：根据 Redis 配置文件中的 save 选项来自动触发<div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 在 900 秒内如果有至少 1 个键被改动，则自动触发 RDB 持久化</span>
<span class="token comment"># 配置名虽然是 save，实际上执行的是 bgsave 命令</span>
save <span class="token number">900</span> <span class="token number">1</span>
<span class="token comment"># 在 300 秒内如果有至少 10 个键被改动...</span>
save <span class="token number">300</span> <span class="token number">10</span>
<span class="token comment"># 在 60 秒内如果有至少 10000 个键被改动...</span>
save <span class="token number">60</span> <span class="token number">10000</span>
<span class="token comment"># 关闭RDB快照功能</span>
save <span class="token string">&quot;&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul> <p>（3）RDB 日志文件加载方式</p> <p>RDB 文件的加载工作是在服务器<strong>启动时自动执行</strong>的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p> <p><img src="/blog/assets/img/image-18.6937019e.png" alt="alt text"></p> <p>（4）RDB 优点</p> <ol><li>RBD 日志文件是紧凑的二进制文件（使用LZF算法进行压缩），非常适合用于备份和数据传输</li> <li>数据恢复速度很快（远远快于AOF方式）</li> <li>RBD 配置比较灵活，提供了 save 选项自定义快照触发间隔</li></ol> <p>（5）RDB 缺点</p> <ol><li>RDB方式实时性不够，无法做到秒级的持久化，丢失风险很大</li> <li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高（RDB 是全量的持久化）</li></ol> <p>（6）配置参数</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 指定 RDB 文件的保存目录</span>
<span class="token function">dir</span> ./
<span class="token comment"># 指定 RDB 文件的名称</span>
dbfilename dump.rdb
<span class="token comment"># RDB 持久化触发条件</span>
save <span class="token number">900</span> <span class="token number">1</span>
save <span class="token number">300</span> <span class="token number">10</span>
save <span class="token number">60</span> <span class="token number">10000</span>
<span class="token comment"># 如果持久化出错，主进程是否停止写入</span>
stop-writes-on-bgsave-error <span class="token function">yes</span>
<span class="token comment"># 是否压缩</span>
rdbcompression <span class="token function">yes</span>
<span class="token comment"># 导入时是否检查</span>
rdbchecksum <span class="token function">yes</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>2️⃣ AOF 持久化</p> <p>（1）概念</p> <p>虽说 Redis 是内存数据库，但是它为数据的持久化提供了两个技术，分别是 <strong>AOF 日志</strong> 和 <strong>RDB 快照</strong>：</p> <ul><li>AOF 文件记录的是命令操作的日志，而不是实际的数据
<ul><li>AOF(Append Only File) 日志 <strong>只会记录写操作命令到日志</strong> 中。</li></ul></li> <li>RDB 快照就是记录某一个瞬间的内存数据（实际数据）</li></ul> <p>这两种技术都会用各用一个日志文件来记录信息，但是记录的内容是不同的：</p> <ul><li>AOF 文件的内容是操作命令；</li> <li>RDB 文件的内容是二进制数据。</li></ul> <p><img src="/blog/assets/img/image-17.83324a29.png" alt="alt text"></p> <p>如图所示，Redis 的 AOF 是写后日志，即“先执行命令把数据写入内存，再记录命令到日志”。<span style="color:rgb(122 116 116);">但其实很多数据库采用的是写前日志（WAL），例如 MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</span></p> <p>（2）配置参数</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment"># 表示是否开启 AOF 持久化（默认no）</span>
appendonly <span class="token function">yes</span>                   
<span class="token comment"># AOF 持久化文件的名称</span>
appendfilename <span class="token string">&quot;appendonly.aof&quot;</span>  
<span class="token comment"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span>
<span class="token function">dir</span> ./
<span class="token comment"># 同步策略 always/everysec/no</span>
appendfsync everysec
<span class="token comment"># aof重写期间是否同步</span>
no-appendfsync-on-rewrite no
<span class="token comment"># 重写触发配置</span>
auto-aof-rewrite-percentage <span class="token number">100</span>  <span class="token comment"># (当前aof文件大小 - 上一次重写后aof文件大小) / 上一次重写后aof文件大小</span>
auto-aof-rewrite-min-size 64mb   <span class="token comment"># 重写时文件的最小大小</span>
<span class="token comment"># 加载aof出错如何处理</span>
aof-load-truncated <span class="token function">yes</span>
<span class="token comment"># 文件重写策略</span>
aof-rewrite-incremental-fsync <span class="token function">yes</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Q：在重写日志整个过程时，主线程有哪些地方会被阻塞？<br>
A：1) fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。2) 主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。3) 子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。</p> <p>参考：</p> <ul><li><a href="https://www.xiaolincoding.com/redis/storage/aof.html" target="_blank" rel="noopener noreferrer">AOF 持久化是怎么实现的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.xiaolincoding.com/redis/storage/rdb.html" target="_blank" rel="noopener noreferrer">RDB 持久化是怎么实现的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html" target="_blank" rel="noopener noreferrer">Redis进阶 - 持久化：RDB和AOF机制详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>12. 使用 Redis 如何实现分布式锁？</summary> <p>1️⃣ 答：</p> <p>Redis 的 SET 命令有个 <code>NX</code> 参数表示 “ <code>key</code> 不存在才插入”，可以用它来实现分布式锁：</p> <ul><li>如果 <code>key</code> 不存在，则显示插入成功，可以用来表示加锁成功；</li> <li>如果 <code>key</code> 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul> <p><strong>1）加锁</strong></p> <p>分布式锁命令：</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>SET lock_key unique_value NX PX <span class="token number">10000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>lock_key</code> 就是上面提到的 <code>key</code></li> <li><code>unique_value</code> 是客户端生成的唯一的标识，区分来自不同客户端的锁操作</li> <li><code>NX</code> 代表只在 <code>lock_key</code> 不存在时，才对 <code>lock_key</code> 进行设置操作</li> <li><code>PX 10000</code> 表示设置 <code>lock_key</code> 的过期时间为 <code>10s</code>，这是为了避免客户端发生异常而无法释放锁。</li></ul> <p><strong>2）解锁</strong></p> <p>解锁的过程就是将 <code>lock_key</code> 键删除，但不能乱删，要保证执行删除操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 <code>unique_value</code> 是否为加锁客户端，是的话，才将 <code>lock_key</code> 键删除。</p> <p>解锁有两个操作，这时就需要 Lua 脚本来保证解锁的原子性（执行时具备原子性，因为 Lua 脚本是单线程的）：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 先比较 unique_value 是否相等，避免锁的误释放</span>
<span class="token comment">// ARGV[1]      即执行删除操作的客户端</span>
<span class="token comment">// get lock_key 即持有锁的客户端</span>
<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then
    <span class="token comment">// 释放锁（del lock_key）</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;del&quot;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p> <p>参考：<a href="https://www.xiaolincoding.com/redis/base/redis_interview.html#%E5%A6%82%E4%BD%95%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84" target="_blank" rel="noopener noreferrer">如何用Redis实现分布式锁？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details> <details class="custom-block details"><summary>13. 除了 Redis 还有哪种实现分布式锁的方式？</summary> <p>可以使用 Zookeeper 实现分布式锁 → 多个请求同时创建一个临时节点的方式来实现分布式锁，临时节点就是锁，而临时节点只有一个请求能创建成功。</p></details> <details class="custom-block details"><summary>14. Redis 集群是如何分片的？这种分片算法有什么好处？</summary> <p>1️⃣ 答：</p> <p><strong>Redis集群/Redis-cluster</strong>：</p> <p>Redis-cluster对外是一个整体（相当于单Redis），每个master只负责存储整个数据集的一部分（而单Redis/主从复制/哨兵机制都是存储整个数据集）。这样的话，原本存储的整个数据集现在都分散到多台Redis机器上，称为分片。</p> <p><strong>Redis集群分片算法</strong>：哈希槽分片算法</p> <p>Redis-cluster没有使用<a href="https://blog.csdn.net/weixin_39094034/article/details/128264838" target="_blank" rel="noopener noreferrer">一致性哈希算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，而是引入了哈希槽（Hash Slot）的概念，Redis-cluster中有 16384(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mn>2</mn><mn>1</mn></msup><mn>4</mn></mrow><annotation encoding="application/x-tex">=2^14</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">4</span></span></span></span>) 个哈希槽。</p> <p><img src="/blog/assets/img/image-19.9e8ef55a.png" alt="alt text"></p> <p>如上图所示，有：</p> <ul><li>Redis-cluster中的每个节点负责一部分槽哈希槽。
<ul><li>例如集群中有三个master，则可能的一种哈希槽分配管理：
<ul><li><ol><li>Redis1 负责 0-5500 号哈希槽</li></ol></li> <li><ol start="2"><li>Redis2 负责 5501-11000 号哈希槽</li></ol></li> <li><ol start="3"><li>Redis3 负责 11001-16384 号哈希槽</li></ol></li></ul></li></ul></li> <li>每个 key 通过 CRC16 校验后对 16383 取模来决定放置哪个槽。<div class="language-sh line-numbers-mode"><pre class="language-sh"><code>HASH_SLOT <span class="token operator">=</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> mod <span class="token number">16384</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <p><strong>Hash槽分片算法优点</strong>：</p> <ul><li>防止数据倾斜（一致性哈希算法存在该问题）：将哈希槽尽量平均分给每个节点</li> <li>分工更均衡：
<ul><li>删除一个节点：删除节点的哈希槽平分到其余的每个节点</li> <li>添加一个节点：将每个节点的一部分哈希槽转移分配到新增节点</li></ul></li></ul> <p><span style="color:rgb(122 116 116);">集群的优点</span></p> <ul><li>高可用：由于数据分布在多个节点上，即使其中一个节点发生故障，其他节点仍然可以继续工作，提供高可用性。</li> <li>高可拓展：可以根据需求动态添加或移除节点</li></ul> <p>参考</p> <ul><li><a href="https://blog.csdn.net/qq_56044032/article/details/129902475" target="_blank" rel="noopener noreferrer">Redis集群分片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html#%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">Redis 集群的设计目标|Java全栈<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.yuque.com/snailclimb/mf2z3k/ikf0l2" target="_blank" rel="noopener noreferrer">Redis Cluster|JavaGuide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.bilibili.com/video/BV1ge411L7Sh" target="_blank" rel="noopener noreferrer">趣话Redis：Redis集群是如何工作的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>15. 说说 JVM 的内存分布</summary> <p>1️⃣ 答：</p> <p>JVM 内存布局：</p> <ol><li><strong>Java虚拟机栈</strong> → 线程私有，FILO，由一个个栈帧组成，存储线程执行的函数，包含函数的局部变量、中间计算结果、函数调用和返回</li> <li><strong>本地方法栈</strong> → 线程私有，与Java虚拟机栈的功能一致，不过该栈为本地方法（C++实现）服务。在 HotSpot 中，Java虚拟机栈和本地方法栈合二为一（用同一块内存空间）。</li> <li><strong>程序计数器</strong> → 线程私有，记录线程执行位置，主要两个作用：1）在线程运行时，字节码解释器通过获取和改变程序计数器来控制代码的执行流程；2）在多线程的情况下，程序计数器记录线程执行位置，从而在线程上下文切换时，可以知道切换回来的线程上次运行到哪里了。</li> <li><strong>堆</strong> → 存放实例对象，几乎所有的对象实例以及数组都在这里分配内存。堆是JVM管理的内存中最大的一块，也是垃圾收集器管理的主要区域。</li> <li><strong>方法区</strong> → 存储类和常量的信息，包括类的定义、方法的定义、字段的定义以及字节码指令等</li></ol> <p>更详细可查看：<a href="#%E8%85%BE%E8%AE%AFqq-%E4%B8%80%E9%9D%A2-2024-04-23">腾讯qq-一面-Q3</a></p></details> <details class="custom-block details"><summary>16. 这些内存区域中有垃圾回收的是哪些地方？</summary> <p>1️⃣ 答：</p> <p>JVM 垃圾回收区域：</p> <ol><li>堆（几乎所有的对象实例以及数组都在这里分配内存，对象大部分都朝生夕死，需要回收）</li> <li>方法区（类或方法卸载时需要回收）</li></ol></details> <details class="custom-block details"><summary>17. Spring 的 AOP 是如何实现的？</summary> <p>1️⃣ 答：</p> <p>Spring AOP 由动态代理实现 AOP：</p> <ol><li>JDK Proxy （Spring默认使用）</li> <li>CGLib （SpringBoot默认使用）</li></ol> <p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p> <p>使用AspectJ来做切入点解析和匹配。但是，AOP在运行时仍旧是纯的Spring AOP，并不依赖于AspectJ的编译器或者织入器（weaver）。</p> <p>Spring AOP的实现方式是动态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的；如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术。</p></details> <details class="custom-block details"><summary>18. Kafka 吞吐量高得原理是啥？</summary></details> <details class="custom-block details"><summary>19. Kafka 如何保证数据不丢失？</summary></details> <details class="custom-block details"><summary>20. 手撕算法：恢复乱序数组</summary> <p>恢复乱序数组 → 有序数组</p> <p>排序算法：</p> <ol><li>冒泡排序</li> <li>插入排序</li> <li>归并排序（分治法）</li> <li>快速排序</li></ol></details> <h3 id="腾讯qq-一面-2024-04-23"><a href="#腾讯qq-一面-2024-04-23" class="header-anchor">#</a> 腾讯QQ（一面） - 2024.04.23</h3> <details class="custom-block details"><summary>1. Java 当中形参是数组或者对象的话，修改形参会对实参影响吗？</summary> <p>1️⃣ 答：</p> <p>在 Java 中，将实参传递给方法的方式是值传递，对于数组或者对象，分两种情况考虑：</p> <ul><li>如果对形参变量重新赋值（<code>new</code> 新的数组或对象），则不会影响实参；</li> <li>如果（形参变量不重新赋值）通过形参修改数组中的元素或对象的属性，则会影响实参。</li></ul> <p>这是因为当参数是数组或对象时，实参变量保存的是数组或对象的地址值（地址值也是值），传递给形参的值也是地址值，此时形参和实参保存的地址值相同，指向的数组或对象是一样的。</p> <p>所以，如果不对形参重新赋值而只修改形参（数组或对象）里的属性，则会修改到地址值指向的数组的元素或对象的属性，而实参保存的地址值与形参一致，因此影响了实参；如果直接对形参重新赋值，则该形参保存的是新的地址值（与实参的不同），后续对形参的修改都不会影响实参。</p></details> <details class="custom-block details"><summary>2. 说说 Java 的序列化？</summary> <p>1️⃣ 答：</p> <p>Java 序列化是指将 Java 对象转换为字节序列（二进制字节流）的过程，以便在网络上传输或将其持久化（写入持久存储，如文件或数据库）。</p> <p>Java 序列化通常涉及到 <code>Serializable</code> 接口和 <code>ObjectOutputStream</code>、<code>ObjectInputStream</code> 类。</p> <ul><li><strong><code>Serializable</code> 接口</strong>：序列化的类需要实现 <code>Serializable</code> 接口，这个接口没有任何方法，它只是作为一个标记接口（marker interface）使用，表示该类创建的对象是可以被序列化的，但是如果不去实现它而进行序列化的话，会抛出异常。如果类的某个属性不可序列化，则必须将其标记为 <code>transient</code>，以告诉 Java 在序列化时忽略这个属性。</li> <li><strong><code>ObjectOutputStream</code> 类</strong>：通常使用 <code>ObjectOutputStream</code> 类的 <code>writeObject</code> 方法来完成序列化（将对象转换为字节序列）。</li> <li><strong><code>ObjectInputStream</code> 类</strong>：通常使用 <code>ObjectInputStream</code> 类的 <code>readObject</code> 方法来完成反序列化（将字节序列转换为对象）。</li></ul> <p>2️⃣ 细节</p> <ol><li><p>序列化和反序列化：<a href="https://javaguide.cn/java/basis/serialization.html" target="_blank" rel="noopener noreferrer">参考1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://pdai.tech/md/java/io/java-io-basic-usage.html#%E5%BA%8F%E5%88%97%E5%8C%96-serializable-transient" target="_blank" rel="noopener noreferrer">参考2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>序列化的注意事项：</p></li></ol> <ul><li>安全性：序列化涉及将对象转换为字节流，这可能会暴露对象的内部状态。因此，在序列化对象之前，应确保对象不包含敏感信息，或者已经采取了适当的安全措施。</li> <li>版本控制：当类的定义发生变化时（例如，添加或删除字段），已经序列化的对象可能无法正确地反序列化。Java提供了一种称为 serialVersionUID 的机制来处理这个问题。当类的定义改变时，应更新此字段的值。</li> <li>性能：序列化过程可能会消耗较多的CPU和内存资源，尤其是在处理大型对象或复杂对象图时。因此，在性能敏感的应用程序中，应谨慎使用序列化。</li> <li>自定义序列化：如果需要更细粒度的控制序列化过程，可以通过实现 <code>java.io.Externalizable</code> 接口或提供 <code>writeObject</code> 和 <code>readObject</code> 方法的私有实现来完成。</li> <li>瞬态变量：被标记为 <code>transient</code> 的变量在序列化过程中会被忽略，这可以用于排除敏感数据或不需要持久化的数据。</li></ul> <ol start="3"><li><p><strong>一个常用的序列化技术：JSON 序列化</strong>。JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。在Java中，可以使用如Jackson、Gson等库将Java对象转换为JSON格式的字符串，或将JSON字符串转换为Java对象。这种方式通常用于HTTP请求的发送和接收，或者作为配置文件等数据的存储格式。</p></li> <li><p>关于 Java 序列化的10个面试问题：<a href="https://blog.csdn.net/seeseeyoua/article/details/127869439" target="_blank" rel="noopener noreferrer">参考文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ol></details> <details class="custom-block details"><summary>3. 说说 JVM 内存模型，每个区域是干什么的？</summary> <p>⚠️ 注意，要区分 JVM 内存模型（JMM） 和 JVM 内存结构！两者是完全不同的东西。</p> <p>这个问题问得有点问题，一般 JVM 内存结构才讲究区域，JVM 内存模型并没有这样子的说法。所以我个人觉得这里问的其实是 JVM 内存结构，</p> <p><strong>那问题就改成：说说 JVM 内存结构，每个区域是干什么的？</strong></p> <p>1️⃣ 答：</p> <p>JVM内存结构主要指的是 JVM 运行时数据区域（Runtime Data Area）。在执行 Java 程序的过程中，JVM 会把它管理的内存划分成若干个不同的数据区域。</p> <ul><li>线程私有 <em>（这些内存结构的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡）</em>：
<ul><li><strong>虚拟机栈 / VM Stack</strong>：主管 Java 程序的运行，它保存单个线程中的方法的局部变量、部分结果，并参与方法的调用和返回。</li> <li><strong>本地方法栈 / Native Method Stack</strong>：作用与虚拟机栈相似，但该栈为本地方法（C++实现）服务，用于保存本地方法执行时使用到的变量、局部结果、方法的调用和返回。</li> <li><strong>程序计数器 / Program Counter Register</strong>：相当于当前线程执行的行号指示器。
<ul><li>在线程运行时，字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li> <li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</li></ul></li></ul></li> <li>线程共享
<ul><li><strong>堆 / Heap</strong>：存放对象实例，<strong>几乎所有</strong>的对象实例以及数组都在这里分配内存。堆是JVM 管理的内存中最大的一块，也是垃圾收集器管理的主要区域。</li> <li><strong>方法区 / Method Area</strong> (No-Heap)：方法区是 JVM 中的一个逻辑区域，用于存储类的结构信息，包括类的定义、方法的定义、字段的定义以及字节码指令。</li> <li><strong>直接内存 / Direct Memory</strong> (非运行时数据区的一部分)：一个特殊的内存缓冲区，通过 JNI 的方式在本地内存上分配的。</li></ul></li></ul> <p>2️⃣ 细节</p> <p>JDK 1.7（及以下）：</p> <p>首先，按照线程私有和线程共享的特性区分：</p> <ul><li>线程私有：这些内存结构的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡
<ul><li><strong>虚拟机栈 / VM Stack</strong>：主管 Java 程序的运行，它保存单个线程中的方法的局部变量、部分结果，并参与方法的调用和返回。
<ul><li>栈包含一个个栈帧（Stack Frame），一次方法调用就会有一个栈帧入栈，方法执行结束则栈帧出栈</li> <li>可能的异常：1）栈固定大小时可能 <code>StackOverflowError</code>；2）栈动态扩展时可能 <code>OutOfMemoryError</code></li></ul></li> <li><strong>本地方法栈 / Native Method Stack</strong>：作用与虚拟机栈一样，但该栈为本地方法（C++实现）服务，用于保存本地方法执行时使用到的变量、链接、返回等。
<ul><li>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</li> <li>在 HotSpot 虚拟机中，本地方法栈 和 虚拟机栈 合二为一</li></ul></li> <li><strong>程序计数器 / Program Counter Register</strong>：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
<ul><li>在线程运行时，字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li> <li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了</li></ul></li></ul></li> <li>线程共享
<ul><li><strong>堆 / Heap</strong>：存放对象实例，<strong>几乎所有</strong>的对象实例以及数组都在这里分配内存。堆是JVM 管理的内存中最大的一块，也是垃圾收集器管理的主要区域
<ul><li><strong>字符串常量池 / String Constant Pool</strong>：针对字符串（String 类）专门开辟的一块区域，存放字符串常量，为了避免字符串的重复创建，以及提升性能和减少内存消耗。</li> <li>...</li></ul></li> <li><strong>方法区 / Method Area</strong> (No-Heap)
<ul><li><strong>运行时常量池 / Runtime Constant Pool</strong>：在运行时期间，JVM 会将字节码文件中的常量池加载到内存中，存放在运行时常量池中。
<ul><li>Class 文件中的常量池表(Constant Pool Table)，存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的</li> <li>常量池是在字节码文件中，而运行时常量池在 JVM 中</li></ul></li> <li>...</li></ul></li> <li><strong>直接内存 / Direct Memory</strong> (非运行时数据区的一部分)</li></ul></li></ul> <p>JDK 1.8（及以上）：</p> <p>大体上与上述相同，有几个区别</p> <ul><li>JDK1.7 之前，字符串常量池存放在永久代（方法区）。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</li> <li>...</li></ul></details> <details class="custom-block details"><summary>4. 垃圾回收算法有哪些？</summary> <p>1️⃣ 答：</p> <ol><li><strong>标记-清除算法</strong></li></ol> <p>「标记-清除」（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p> <p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p> <ul><li>效率问题：标记和清除两个过程效率都不高。</li> <li>空间问题：标记清除后会产生大量不连续的内存碎片。</li></ul> <ol start="2"><li><strong>复制算法</strong></li></ol> <p>为了解决「标记-清除」算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以<strong>将内存分为大小相同的两块，每次使用其中的一块</strong>。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p> <p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p> <ul><li>可用内存变小：可用内存缩小为原来的一半。</li> <li>不适合老年代：如果存活对象数量比较大，复制性能会变得很差。</li></ul> <blockquote><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p> <p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote> <ol start="3"><li><strong>标记-整理算法</strong></li></ol> <p>「标记-整理」（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与「标记-清除」算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p> <p>由于多了整理这一步，因此效率也不高，<strong>适合老年代这种垃圾回收频率不是很高的场景</strong>。</p> <ol start="4"><li><strong>分代收集算法</strong></li></ol> <p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。<strong>一般将 Java 堆分为新生代和老年代</strong>，这样我们就可以<strong>根据各个年代的特点选择合适的垃圾收集算法</strong>。</p> <p>比如：</p> <ul><li><strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</li> <li>而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择「<strong>标记-清除</strong>」或「<strong>标记-整理</strong>」算法进行垃圾收集。</li></ul> <p>2️⃣ 扩展问题</p> <p>Q: 延伸面试问题： HotSpot 为什么要分为新生代和老年代？<br>
A: 根据上面的对分代收集算法的介绍回答</p> <hr> <p>Q&amp;A: 分代垃圾回收算法执行过程：</p> <ul><li>初始态：对象分配在Eden区，S0、S1区几乎为空。</li> <li>随着程序的运行，越来越多的对象被分配在Eden区。</li> <li>当Eden放不下时，就会发生MinorGC（即YoungGC），此时，会先标识出不可达的垃圾对象，然后将可达的对象移动到S0区，并将不可达的对象清理掉。这时候，Eden区就是空的了。在这个过程中，使用了标记清理算法及标记复制算法。</li> <li>随着Eden放不下时，会再次触发minorGC，和上一步一样，先标记。这个时候，Eden和S0区可能都有垃圾对象了，而S1区是空的。这个时候，会直接将Eden和S0区的对象直接搬到S1区，然后将Eden与S0区的垃圾对象清理掉。经历这一轮的MinorGC后，Eden与S0区为空。</li> <li>随着程序的运行，Eden空间会被分配殆尽，这时会重复刚才MinorGC的过程，不过此时，S0区是空的，S0和S1区域会互换，此时存活的对象会从Eden和S1区，向S0区移动。然后Eden和S1区中的垃圾会被清除，这一轮完成之后，这两个区域为空。</li> <li>在程序运行过程中，虽然大多数对象都会很快消亡，但仍然存在一些存活时间较长的对象，对于这些对象，在S0和S1区中反复移动，会造成一定的性能开销，降低GC的效率。因此引入了对象晋升的行为。</li> <li>当对象在新生代的Eden、S0、S1区域之间，每次从一个区域移动到另一个区域时，年龄都会加一，在达到一定的阈值后，如果该对象仍然存活，该对象将会晋升到老年代。</li> <li>如果老年代也被分配完毕后，就会出现MajorGC（即Full GC），由于老年代通常对象比较多，因此标记-整理算法的耗时较长，因此会出现STW现象，因此大多数应用都会尽量减少或着避免出现Full GC的原因。</li></ul> <hr> <p>Q: 垃圾回收器有哪些？<br>
A: 以下是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p> <p><img src="/blog/assets/img/image-1.2fb8c60d.png" alt="7 个垃圾收集器"></p> <p>前置知识：</p> <ul><li><strong>单线程</strong>&amp;<strong>多线程</strong>: 「单线程」指的是垃圾收集器只使用一个线程进行收集，而「多线程」使用多个线程；</li> <li><strong>串行</strong>&amp;<strong>并行</strong>: 「串行」指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序（必须暂停其他所有的工作线程(&quot;Stop The World&quot;)）；「并行」指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul> <p>垃圾回收器：</p> <ol><li>Serial 收集器</li></ol> <p><img src="/blog/assets/img/image-2.f689bb7d.png" alt="Serial 收集器"></p> <p>它是单线程的收集器，<strong>只会使用一个线程进行、以串行的方式执行</strong>垃圾收集工作。</p> <p><strong>它是 Client 模式下的默认新生代收集器</strong>，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p> <p>它的优点是<strong>简单高效</strong>，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p> <ol start="2"><li>ParNew 收集器</li></ol> <p><img src="/blog/assets/img/image-3.c0ad1318.png" alt="ParNew 收集器"></p> <p>ParNew 收集器 其实就是 <strong>Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p> <p>它是许多运行在 <strong>Server 模式下的虚拟机的首要选择</strong>，除了 Serial 收集器外，<strong>只有它能与 CMS 收集器配合工作</strong>（真正意义上的并发收集器）。</p> <ol start="3"><li>Parallel Scavenge 收集器</li></ol> <p>与 ParNew 一样是<strong>多线程收集器</strong>。</p> <p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为 <strong>“吞吐量优先”收集器</strong>。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p> <p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，则可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p> <ol start="4"><li>Serial Old 收集器</li></ol> <p><img src="/blog/assets/img/image-4.ba8fa25c.png" alt="Serial Old"></p> <p><strong>Serial 收集器的老年代版本</strong>，<strong>单线程</strong>收集器，也是<strong>给 Client 模式下的虚拟机使用</strong>。</p> <p>如果用在 Server 模式下，它有两大用途:</p> <ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li> <li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul> <ol start="5"><li>Parallel Old 收集器</li></ol> <p><img src="/blog/assets/img/image-5.b65529b2.png" alt="Parallel Old 收集器"></p> <p><strong>Parallel Scavenge 收集器的老年代版本</strong>，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器。</p> <ol start="6"><li>CMS 收集器</li></ol> <p><img src="/blog/assets/img/image-6.68c0d19c.png" alt="CMS 收集器"></p> <p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是<strong>标记-清除算法</strong>。</p> <p>CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</p> <p>CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p> <p>它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p> <ul><li>Step1 <strong>初始标记</strong>： <strong>暂停所有的其他线程</strong>，并记录下 GC Roots 能直接关联到的对象，速度很快；<em>(需要停顿)</em></li> <li>Step2 <strong>并发标记</strong>： <strong>同时开启 GC 和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方；<em>(不需要停顿)</em></li> <li>Step3 <strong>重新标记</strong>： 为了修正 Step2并发标记期间 因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录；<em>（需要停顿）</em></li> <li>Step4 <strong>并发清除</strong>： <strong>开启用户线程，同时 GC 线程开始</strong>对未标记的区域做清扫。<em>（不需要进行停顿）</em></li></ul> <p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。</p> <p>但是它有下面三个明显的缺点：1）对 CPU 资源敏感；2）无法处理浮动垃圾；3）它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p> <p>从 JDK9 开始，CMS 收集器已被弃用（G1 垃圾收集器成为了默认的垃圾收集器）。</p> <ol start="7"><li>G1 收集器</li></ol> <p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。</p> <p>堆被分为新生代和老年代，<strong>其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收</strong>。</p> <p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离，如图所示：</p> <p><img src="/blog/assets/img/image-7.002cf092.png" alt="alt text"></p> <p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。</p> <p>G1 收集器通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，<strong>并在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p> <p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p> <p><img src="/blog/assets/img/image-8.a31f062d.png" alt="alt text"></p> <p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致分为以下几个步骤：</p> <ul><li>Step1 <strong>初始标记</strong></li> <li>Step2 <strong>并发标记</strong></li> <li>Step3 <strong>最终标记</strong>：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li> <li>Step4 <strong>筛选回收</strong>：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul> <p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p> <ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li> <li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li> <li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li> <li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul> <p>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</p> <p><a href="https://pdai.tech/md/java/jvm/java-jvm-gc.html" target="_blank" rel="noopener noreferrer">更多关于GC知识<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details> <details class="custom-block details"><summary>5. 垃圾回收算法为什么只用于堆？</summary> <p>1️⃣ 答：</p> <p>垃圾回收算法主要应用于堆（Heap）：</p> <ol><li>堆是 JVM 中用于存储对象实例和数组的主要区域，这些对象在程序运行时<strong>动态</strong>创建和销毁，其生命周期是最不稳定的。因此，需要垃圾回收机制来自动追踪和回收不再使用的对象，以释放内存。</li> <li>栈内存的特性：相比之下，栈内存用于存储方法调用的局部变量和方法的执行上下文。栈上的数据具有明确的生命周期，通常与方法的执行周期相对应。当方法执行完毕并返回时，栈帧被弹出，其所占用的内存自动释放。由于栈内存的这种自动管理特性，不需要垃圾回收算法来介入。</li></ol></details> <details class="custom-block details"><summary>6. 什么是新生代？什么是老年代？</summary> <p>1️⃣ 答：</p> <p>新生代（Young Generation）和老年代（Old Generation）是堆内存的两个主要部分，用于存储对象。这种内存划分有助于优化垃圾回收的性能。</p> <p><strong>新生代</strong></p> <ul><li>主要用于存放新创建的对象。新生代会分为三个区域：
<ul><li>Eden（伊甸园，80%）</li> <li>S0（Survivor 0 区，10%）</li> <li>S1（Survivor 1 区，10%）</li></ul></li></ul> <p><strong>老年代</strong></p> <ul><li>一方面，用于存放那些在新生代中经历了多次垃圾回收仍然存活的对象。这些对象通常生命周期较长。</li> <li>另一方面，大对象直接进入老年代，这是内存分配策略之一。</li> <li>（延伸）当老年代空间不足以容纳新存活的对象时，会触发 Full GC，这种GC通常比Minor GC耗时更长，因为它涉及的对象更多，且可能需要暂停所有应用线程。</li></ul> <p>2️⃣ 扩展问题</p> <ol><li>Minor GC 和 Full GC 有什么不同？</li></ol> <p>答：</p> <ul><li><strong>回收对象/区域</strong>：
<ul><li>Minor GC 只对新生代进行垃圾收集，这个区域通常用于存放新创建的对象。Minor GC 主要回收新生代中不再被引用的对象；</li> <li>Full GC 则针对整个堆内存进行回收，包括新生代和老年代。</li></ul></li> <li><strong>发生频率</strong>：Minor GC 通常比 Full GC 更频繁。
<ul><li>新生代中的对象具有较短的生命周期，意味着新生代中会产生大量的垃圾对象，需要频繁地进行垃圾回收以释放内存空间，因此触发 Minor GC 的频率比较高；</li> <li>相比之下，老年代中的对象通常具有较长的生命周期，相对稳定一些，而且 Full GC 的触发条件相对苛刻，因此 Full GC 的执行频率相对较低。</li></ul></li> <li><strong>对系统性能的影响</strong>：
<ul><li>Minor GC 只涉及新生代内存的回收，其执行速度通常较快，对系统性能的影响较小；</li> <li>Full GC 涉及整个堆内存的回收，对系统的性能和响应时间产生较大的影响。</li></ul></li></ul> <p>细节：</p> <p>（1）GC 种类</p> <p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p> <ul><li><strong>部分收集 (Partial GC)</strong>：
<ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li> <li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。
<ul><li><span style="color:rgb(122 116 116);">目前，只有 CMS GC 会有单独收集老年代的行为</span></li> <li><span style="color:rgb(122 116 116);">需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</span></li></ul></li> <li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li> <li><strong>整堆收集 (Full GC)</strong>：收集整个 Java 堆和方法区。</li></ul> <p>（2）Full GC 的触发条件</p> <p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。</p> <p>而 Full GC 则相对复杂，有以下条件：</p> <ul><li>调用 <code>System.gc()</code></li> <li>老年代空间不足</li> <li>空间分配担保失败</li> <li>JDK 1.7 及以前的永久代空间不足</li> <li><code>Concurrent Mode Failure</code></li></ul> <hr> <ol><li>GC 如何判断回收的垃圾对象？</li></ol> <p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）：</p> <p><strong>方法1：引用计数法</strong></p> <p>给对象中添加一个引用计数器：</p> <ul><li>每当有一个地方引用它，计数器就加 1；</li> <li>当引用失效，计数器就减 1；</li> <li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul> <p>优点：实现简单，效率高</p> <p>缺点：目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</p> <p><strong>方法2：可达性分析法</strong></p> <p>这个算法的基本思想就是通过一系列的称为 “<strong>GC Roots</strong>” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p> <p><strong>哪些对象可以作为 GC Roots 呢？</strong></p> <ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li> <li>本地方法栈(Native 方法)中引用的对象</li> <li>方法区中类静态属性引用的对象</li> <li>方法区中常量引用的对象</li> <li>所有被同步锁持有的对象</li> <li>JNI（Java Native Interface）引用的对象</li></ul></details> <details class="custom-block details"><summary>7. 老年代当中的对象有什么特点？</summary> <p>1️⃣ 答：</p> <p>老年代中的对象的特点：</p> <ul><li>生命周期更长：<span style="color:rgb(122 116 116);">老年代主要用于存放那些在新生代中经历了多次垃圾回收仍然存活的对象。这些对象通常已经证明了它们的长期价值，因此被移至老年代以继续保留。</span></li> <li>对象通常比较大
<ul><li><span style="color:rgb(122 116 116);">内存分配策略之一：大对象直接进入老年代</span></li> <li>...</li></ul></li> <li>对象的稳定性更高：<span style="color:rgb(122 116 116);">由于老年代中的对象存活时间较长，因此这些对象相对稳定，不会像新生代中的对象那样频繁地被创建和销毁</span>。</li></ul></details> <details class="custom-block details"><summary>8. 创建线程的方式有哪些？</summary> <p>1️⃣ 答：</p> <p>Java 中创建线程的三种标准方式：</p> <ol><li>继承 <code>Thread</code> 类，重写 <code>run()</code> 方法</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1) 继承 `Thread` 类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2) 重写 `run()` 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 创建线程对象</span>
        instance<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>实现 <code>Runnable</code> 接口，重写 <code>run()</code> 方法</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1) 实现 `Runnable` 接口</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2) 重写 `run()` 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyRunnable</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 创建线程对象</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="3"><li><span style="color:rgb(122 116 116);">（前两种方式都不能拿到线程的返回值）</span> 实现 <code>Callable</code> 接口，重写 <code>call()</code> 方法，返回值通过 <code>FutureTask</code> 进行封装</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1) 实现 `Callable` 接口，返回值为 Integer</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 2) 重写 `call()` 方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyCallable</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 创建线程对象</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>还有两种有歧义的方式（不建议回答，但可以了解，并明白它们的本质）：</p> <ol><li>Lambda表达式实现 <code>Runnable</code> 接口的方法</li> <li>使用线程池创建：
<ul><li>1）通过 <code>ThreadPoolExecutor</code> 构造函数创建（✅推荐）
<ul><li><code>new ThreadPoolExecutor(...);</code></li></ul></li> <li>2）通过工具类 <code>Executors</code> 来创建（❎不推荐）
<ul><li><code>Executors.newCachedThreadPool(...);</code></li> <li><code>Executors.newFixedThreadPool(...);</code></li> <li><code>Executors.newSingleThreadExecutor(...);</code></li> <li><code>Executors.newScheduledThreadPool(...);</code></li></ul></li></ul></li></ol></details> <details class="custom-block details"><summary>9. 说说线程池的参数</summary> <p>Executors 线程池的类结构关系：</p> <p><img src="/blog/assets/img/image-9.474dd47d.png" alt="alt text"></p> <p>1️⃣ 答：</p> <p>线程池实现类 <code>ThreadPoolExecutor</code> 是 Executor 框架最核心的类。</p> <p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。</p> <p>线程池 <code>ThreadPoolExecutor</code> 的<strong>7个参数</strong>：</p> <ol><li>线程池的<strong>核心线程数量</strong>：<code>int corePoolSize</code></li> <li>线程池的<strong>最大线程数</strong>（核心线程+临时线程数）：<code>int maximumPoolSize</code></li> <li>临时线程的<strong>最大空闲时间</strong>（超过这个时间，临时线程就释放掉）：<code>long keepAliveTime</code></li> <li>参数3的<strong>时间单位</strong>（秒/天/...）：<code>TimeUnit unit</code></li> <li>线程池<strong>任务队列</strong>（是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中）：<code>BlockingQueue&lt;Runnable&gt; workQueue</code></li> <li><strong>线程工厂</strong>（创建线程所用的工厂）：<code>ThreadFactory threadFactory</code></li> <li><strong>拒绝策略</strong>（当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务）：<code>RejectedExecutionHandler handler</code></li></ol> <p>源码如下（忽略细节）：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>       <span class="token comment">// 核心线程数量</span>
        <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>    <span class="token comment">// 最大线程数</span>
        <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>     <span class="token comment">// 最大空闲时间</span>
        <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>          <span class="token comment">// 时间单位</span>
        <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>  <span class="token comment">// 阻塞/任务队列</span>
        <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>        <span class="token comment">// 线程工厂</span>
        <span class="token class-name">RejectedExecutionHandler</span> handler    <span class="token comment">// 拒绝策略</span>
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>2️⃣ 细节
关于线程池，参考：<a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html" target="_blank" rel="noopener noreferrer">JavaGuide|线程池<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details> <details class="custom-block details"><summary>10. 线程池当中有一条空的核心线程？任务来了之后会怎么做？</summary> <p>问题：线程池的核心线程设置为0，任务来了之后怎么做？</p> <p>1️⃣ 答：</p> <p>核心线程数设置为0，当任务来了之后，也会创建一个线程来执行任务，</p> <p>2️⃣ 细节</p> <p>线程池原理分析（参考 JavaGuide）</p> <p>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code> 方法，该方法的实现在 <code>ThreadPoolExecutor</code> 类中。</p> <div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-java"><code>   <span class="token comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//任务队列</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果任务为null，则抛出异常。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ctl 中保存的线程池当前的一些状态信息</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//  下面会涉及到 3 步 操作</span>
        <span class="token comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span>
        <span class="token comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span>
        <span class="token comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果当前工作线程数量为0，新创建一个线程并执行。</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>
        <span class="token comment">// 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span>
        <span class="token comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>详见：<a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" target="_blank" rel="noopener noreferrer">JavaGuide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>线程池处理任务的流程：</p> <p><img src="/blog/assets/img/image-13.3a0fcb8f.png" alt="图解线程池实现原理"></p> <ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个核心线程 <code>addWorker(command, true)</code> 来执行任务。</li> <li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数：
<ul><li>那么就把该任务放入到任务队列里等待执行</li> <li><strong>如果当前运行的线程数为0，则新建一个临时线程</strong> <code>addWorker(null, false);</code>，</li></ul></li> <li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个临时线程来执行任务。</li> <li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用 <code>RejectedExecutionHandler.rejectedExecution()</code> 方法。</li></ol></details> <details class="custom-block details"><summary>12. 说说 HashMap 的特性？</summary> <p>1️⃣ 答：</p> <p>HashMap 的特性：</p> <ol><li>高效读写性能：基于 Hash 表映射的数据结构，底层由数组+链表/红黑树实现。</li> <li>无序性：不能保证先进先出的迭代顺序。（<code>LinkedHashMap</code> 可以，采用双向链表(doubly-linked list)的形式将所有 <code>entry</code> 连接起来，这样可以保证元素的迭代顺序跟插入顺序相同）</li> <li>键唯一，值不唯一，键值允许为 <code>null</code></li> <li>非线程安全的容器</li></ol> <p>2️⃣ 细节</p> <p>更多：</p> <ul><li><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html" target="_blank" rel="noopener noreferrer">集合常见面试题（下）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/qq_20761351/article/details/118947298" target="_blank" rel="noopener noreferrer">HashMap相关面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>13. HashMap 中索引是怎么计算的？</summary> <p>1️⃣ 答：</p> <p>HashMap 索引计算的公式：HashMap 通过 key 的 hashCode <strong>经过扰动函数处理过后得到 hash 值</strong>，然后通过 <code>hash(key) &amp; length-1</code> 判断当前元素存放的位置（这里的 <code>length</code> 指的是数组的长度）</p> <p><code>hash</code> 扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法，换句话说<strong>使用扰动函数之后可以减少碰撞</strong>。</p> <p>HashMap hash 函数：</p> <ol><li>JDK 1.7 之前：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment">// constant multiples at each bit position have a bounded</span>
    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>
    <span class="token comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol><li>JDK 1.8+ ：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></details> <details class="custom-block details"><summary>14. HashMap 的扩容因子是多少？</summary> <p>1️⃣ 答：</p> <p>HashMap 的默认扩容因子是 0.75（性能和占用空间的一种平衡）</p> <p>2️⃣ 细节</p> <p>以下是 HashMap 的其他默认属性</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 序列号</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>
    <span class="token comment">// 默认的初始容量是16</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 最大容量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token comment">// 默认的负载因子</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
    <span class="token comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token comment">// 桶中结构转化为红黑树对应的table的最小容量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
    <span class="token comment">// 存储元素的数组，总是2的幂次倍</span>
    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
    <span class="token comment">// 存放具体元素的集</span>
    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>
    <span class="token comment">// 存放元素的个数，注意这个不等于数组的长度。</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment">// 每次扩容和更改map结构的计数器</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>
    <span class="token comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span>
    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
    <span class="token comment">// 负载因子</span>
    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div></details> <details class="custom-block details"><summary>15. OSI 七层模型各自的作用？</summary> <p>1️⃣ 答：</p> <p>OSI 七层模型，从上往下：</p> <ol><li><strong>应用层/Application</strong>：为计算机用户和应用程序提供服务，例如 DNS（域名解析）</li> <li><strong>表示层/Presentation</strong>：<em>（TCP/IP模型里没有）</em> 负责数据处理（编码解码、加密解密、压缩解压）</li> <li><strong>会话层/Session</strong>：<em>（TCP/IP模型里没有）</em> 管理（建立、维护、重连）应用程序之间的会话</li> <li><strong>传输层/Transport</strong>：为两台主机进程之间的通信提供通用的数据传输服务</li> <li><strong>网络层/Network</strong>：负责路由选择（路由和寻址，决定数据在网络的游走路径）</li> <li><strong>数据链路层/DataLink</strong>：桢编码和误差纠正控制</li> <li><strong>物理层/Physical</strong>：设备层面，透明地传输比特流（硬件基础）</li></ol> <p><img src="/blog/assets/img/image-10.04ca383a.png" alt="osi七层模型2"></p></details> <details class="custom-block details"><summary>16. TCP 为什么是可靠的？</summary> <p>1️⃣ 答：</p> <p>TCP 可靠性保证机制：</p> <ol><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li> <li><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li> <li><strong>重传机制</strong>：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。</li> <li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>（TCP 利用滑动窗口实现流量控制）。</li> <li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。
<ul><li>接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。</li> <li>网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。</li></ul></li></ol> <p>2️⃣ 细节</p> <ul><li>应用层（Application layer）的主要任务就是负责向两台终端设备的应用程序之间提供信息交换服务</li> <li>传输层（Transport layer）的主要任务就是负责向两台终端设备的进程之间的通信提供通用的数据传输服务</li></ul> <p>传输层常见协议：</p> <ul><li>TCP（Transmission Control Protocol，传输控制协议 ）：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li> <li>UDP（User Datagram Protocol，用户数据协议）：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li></ul></details> <details class="custom-block details"><summary>17. TCP 二次握手会出现什么问题？</summary> <p>常见问题：为什么是三次握手？不是两次、四次？</p> <p>比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p> <p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p> <p>1️⃣ 答：</p> <ol><li><p>简洁：
TCP 两次握手时，服务端不能证明自己的发送能力和对方的接收能力。</p></li> <li><p>详细：</p></li></ol> <p>TCP 使用三次握手建立连接的最主要原因就是防止「历史连接」初始化了连接。</p> <p>如果是两次握手连接，就无法阻止「历史连接」，因为在两次握手的情况下，服务端没有中间状态给客户端来阻止「历史连接」，导致服务端可能建立一个「历史连接」，造成资源浪费。</p> <p>🔰 不使用「两次握手」和「四次握手」的原因：</p> <ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li> <li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul></details> <details class="custom-block details"><summary>18. 说说 TCP 三次握手的过程？</summary> <p>1️⃣ 答：</p> <p>TCP 三次握手的过程：</p> <ol><li>一开始，客户端A和服务端B都处于 CLOSE 状态。先是服务端B主动监听某个端口，处于 LISTEN 状态</li> <li>客户端A给服务端B发送请求，之后客户端A状态变更为 SYN-SEND，发送的消息：<code>SYN=1, seq=x</code>（<code>x</code> 是客户端A随机初始化的序号）</li> <li>服务端B接收并响应客户端A，之后服务端B状态变更为 SYN-RCVD，发送的消息： <code>SYN=1, ACK=1, seq=y, ack=x+1</code>（<code>y</code> 是服务端B随机初始化的序号）</li> <li>客户端A接收并响应服务端B（最后一个应答报文），之后客户端A状态变更为 ESTABLISHED，发送的消息： <code>ACK=1, seq=x+1, ack=y+1</code></li> <li>服务端B收到客户端A的应答报文后，状态变更为 ESTABLISHED</li></ol> <p>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端A和服务端B就可以相互发送数据了。</p> <p>注：<code>SYN</code> 和 <code>ACK</code> 是标志位状态，<code>seq</code> 是序列号(32位)，<code>ack</code> 是确认应答号(32位)。</p> <p>如图：</p> <p><img src="/blog/assets/img/image-11.07991830.png" alt="TCP三次握手"></p></details> <details class="custom-block details"><summary>19. 说说 TCP 四次挥手的过程？</summary> <p>1️⃣ 答：</p> <p><strong>双方都可以主动断开连接</strong>，断开连接后主机中的「资源」将被释放。<strong>以客户端主动关闭连接为例</strong>，TCP 四次挥手的过程：</p> <ol><li>一开始，客户端A和服务端B都处于 ESTABLISHED 状态，现在客户端A主动关闭连接</li> <li>客户端A给服务端B发送断开请求，之后客户端A状态变更为 FIN_WAIT_1，发送的消息：<code>FIN=1, seq=u</code>（<code>u</code> 等于客户端A前面已传送过的数据的最后一个字节的序号+1）</li> <li>服务端B接收并响应客户端A（发送ACK应答报文），之后服务端B状态变更为 CLOSE_WAIT，发送的消息： <code>ACK=1, seq=v, ack=u+1</code>（<code>v</code> 等于服务端B前面已传送过的数据的最后一个字节的序号+1）</li> <li>客户端A收到服务端B的ACK应答报文后，状态变更为 FIN_WAIT_2</li></ol> <p>（等待服务端B处理完数据后...）</p> <ol start="5"><li>服务端B给客户端A发送断开请求，之后服务端B状态变更为 LAST_ACK，发送的消息： <code>FIN=1, ACK=1, seq=w, ack=u+1</code>（在CLOSE_WAIT状态可能又发送了一些数据，因此序号变成 <code>w</code>）</li> <li>客户端A接收并响应服务端B（发送ACK应答报文），之后客户端A状态变更为 TIME_WAIT，发送消息： <code>ACK=1, seq=u+1, ack=w+1</code></li> <li>服务端B收到客户端A的应答报文后，状态变更为 CLOSE，至此服务端已经完成连接的关闭</li> <li>客户端A在经过 2MSL(MSL,最长报文段寿命) 时间后，状态变更为 CLOSE，至此客户端也完成连接的关闭。</li></ol> <p>注：<code>FIN</code> 和 <code>ACK</code> 是标志位状态，<code>seq</code> 是序列号(32位)，<code>ack</code> 是确认应答号(32位)。</p> <p>如图：
<img src="/blog/assets/img/image-12.48b12649.png" alt="TCP四次挥手"></p></details> <details class="custom-block details"><summary>20. 键入网址到显示网页，这个过程发生了什么？</summary> <p>1️⃣ 答：</p> <p>URL 执行流程：</p> <ol><li>在「浏览器B」中输入指定网页的 URL，首先会进行正确性效验。
<ul><li>URL（Uniform Resource Locators，统一资源定位符）= 协议+域名/IP+端口+资源路径+参数+锚点</li></ul></li> <li>「浏览器B」通过 DNS 协议，获取「服务器S」域名对应的 IP 地址。</li> <li>「浏览器B」根据 IP 地址和端口号，向「服务器S」发起一个 TCP 连接请求。</li> <li>「浏览器B」在 TCP 连接上，向「服务器S」发送一个 HTTP 请求报文，请求获取网页的内容。</li> <li>「服务器S」收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给「浏览器B」。</li> <li>「浏览器B」收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
<ul><li>HTML 页面中会请求一些后端API，「服务器S」执行业务流程，并响应结果给客户端</li></ul></li> <li>「浏览器B」在不需要和「服务器S」通信时，可以主动关闭 TCP 连接，或者等待「服务器S」的关闭请求。</li></ol> <p>参考：</p> <ul><li><a href="https://www.xiaolincoding.com/network/1_base/what_happen_url.html" target="_blank" rel="noopener noreferrer">键入网址到网页显示，期间发生了什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://javaguide.cn/cs-basics/network/the-whole-process-of-accessing-web-pages.html" target="_blank" rel="noopener noreferrer">访问网页的全过程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>21. 描述一下归并排序和快速排序的实现？</summary> <p>归并排序：分治法。
快排三大特征：
1）找基准值；2）分区排序</p></details> <h3 id="腾讯qq-二面-2024-04-25"><a href="#腾讯qq-二面-2024-04-25" class="header-anchor">#</a> 腾讯QQ（二面） - 2024.04.25</h3> <details class="custom-block details"><summary>1. Java 中类加载的过程？</summary> <p>1️⃣ 答：</p> <p>类加载过程：</p> <ul><li>Step1 加载/Loading：查找并加载类的二进制字节流；</li> <li>Step2 验证/Verifcation：确保被加载的类的正确性；</li> <li>Step3 准备/Preparation：为类的静态变量分配内存，并将其初始化为默认值；</li> <li>Step4 解析/Resolution：把类中的符号引用转换为直接引用；</li> <li>Step5 初始化/Initialization：执行初始化方法 <code>&lt;clinit&gt;()</code>，为类的静态变量赋予正确的初始值</li></ul> <p>2️⃣ 细节</p> <p><a href="/blog/java/jvm/java_jvm_classload.html">跳转</a></p></details> <details class="custom-block details"><summary>2. 解释一下Java中的强引用</summary> <p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p> <p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p> <p>1️⃣ 答：</p> <p>强引用（StrongReference）</p> <p>（1）概念</p> <p>大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝不会回收它</strong>。当内存空间不足，Java 虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p> <p>（2）创建方式：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></details> <details class="custom-block details"><summary>3. 解释一下Java中的其他几种引用类型</summary> <p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p> <p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p> <p>1️⃣ 答：</p> <p><strong>Java 具有四种强度不同的引用类型：</strong></p> <ol><li>强引用（StrongReference）
<ul><li>被强引用关联的对象不会被回收</li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li>软引用（SoftReference）
<ul><li>被软引用关联的对象只有在内存不够的情况下才会被回收</li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 把强引用 obj 释放掉，使对象只被软引用 sf 关联</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li> <li>弱引用（WeakReference）
<ul><li>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li> <li>虚引用（PhantomReference）
<ul><li>形同虚设，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li> <li>虚引用主要用来跟踪对象被垃圾回收的活动。</li> <li>创建方式：<div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li></ol> <p>在程序设计中一般很少使用弱引用与虚引用，<strong>使用软引用的情况较多</strong>，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（<code>OutOfMemory</code>）等问题的产生。</p></details> <details class="custom-block details"><summary>4. 内存泄漏是啥？</summary> <p>1️⃣ 答：</p> <p>内存泄漏是指应用程序中分配的内存（通常是堆内存）在不再需要时未能正确释放。这些未释放的内存块会积累，最终导致应用程序消耗过多的内存资源，甚至可能导致应用程序崩溃或变得非常缓慢。内存泄漏通常是由于不正确的对象引用管理或资源未正确释放而导致的。</p> <p>2️⃣ 细节</p> <p><a href="https://www.cnblogs.com/flydean/p/17722512.html" target="_blank" rel="noopener noreferrer">深入探讨Java面试中内存泄漏：如何识别、预防和解决<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>3️⃣ 扩展问题</p> <ol><li>ThreadLocal 内存泄露问题是怎么导致的？</li></ol> <p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。</p> <p>这样一来，<code>ThreadLocalMap</code> 中就会出现 <code>key</code> 为 <code>null</code> 的 <code>Entry</code>。假如我们不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用 <code>remove()</code> 方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">/** The value associated with this ThreadLocal. */</span>
    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        value <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></details> <details class="custom-block details"><summary>5. 说说进程和线程的区别？</summary> <p>1️⃣ 答：</p> <p>（1）概念</p> <ul><li><strong>进程（Process）</strong> 是指计算机中正在运行的一个程序实例。<span style="color:rgb(122 116 116);">举例：你打开的微信就是一个进程。</span></li> <li><strong>线程（Thread）</strong> 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源，比如内存空间、文件句柄、网络连接等。<span style="color:rgb(122 116 116);">举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</span></li></ul> <blockquote><p>在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是线程。</p></blockquote> <p>（2）区别</p> <ul><li><strong>基本单位</strong>：进程是操作系统<strong>分配资源的基本单位</strong>；线程是<strong>程序执行（CPU调度）的基本单位</strong>；</li> <li><strong>包含关系</strong>：一个进程可以包含一个或多个线程；线程不能包含进程；</li> <li><strong>资源占有</strong>：进程拥有一个完整的资源平台（独立的内存空间和资源）；线程只独享必不可少的资源（如寄存器和栈），共享进程的内存和资源；</li> <li><strong>状态</strong>：进程和线程都具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li> <li><strong>开销</strong>：线程能减少并发执行的时间和空间开销（进程切换的成本比较大；线程切换成本比较小）；</li></ul> <p>对于“线程相比进程能减少开销”，体现在：</p> <ul><li><strong>创建开销</strong>：线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li> <li><strong>销毁开销</strong>：线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li> <li><strong>切换开销</strong>：同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li> <li><strong>交互开销</strong>：由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul></details> <details class="custom-block details"><summary>6. 什么是线程安全？</summary> <p>1️⃣ 答：</p> <p><strong>在Java中，线程安全主要指的是多线程访问同一段代码或数据时，不会产生不确定的结果</strong>（程序执行符合预期）。</p> <p>**换句话说：**在多线程并发执行的情况下，一段程序的运行结果，和单线程下运行它产生的结果是一致的，跟线程数和运行次数没有关系。</p> <p>具体来说，如果一个类或一段代码在多线程环境下执行时，能够表现出正确的行为，并且其结果符合预期，不会因为多线程的交替执行而导致数据不一致或其他不可预测的问题，那么这个类或代码就被认为是线程安全的。</p> <blockquote><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p></blockquote> <p><strong>线程安全三方面/并发三要素</strong>：①原子性、②可见性 和 ③有序性</p> <ul><li>线程安全体现在这三个方面
<ul><li>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行；</li> <li>可见性：指一个线程对共享变量的修改能够立即被其他线程所感知；</li> <li>有序性：保证了线程内的操作按照代码的顺序执行，防止指令重排序优化导致的问题。</li></ul></li> <li>并发问题也是因为这三个方面遭到破坏
<ul><li>原子性：时分复用引起</li> <li>可见性：CPU缓存引起</li> <li>有序性：重排序引起</li></ul></li></ul> <p>2️⃣ 细节</p> <p>更多线程安全的相关知识：</p> <ul><li><a href="https://pdai.tech/md/java/thread/java-thread-x-theorty.html" target="_blank" rel="noopener noreferrer">Java并发理论基础|Java全栈<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://javaguide.cn/java/concurrent/jmm.html#%E5%86%8D%E7%9C%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7" target="_blank" rel="noopener noreferrer">JMM|JavaGuide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html" target="_blank" rel="noopener noreferrer">Java并发常见面试题总结（上）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>7. Java 中保证线程安全的手段有哪些？</summary> <p>1️⃣ 答：</p> <p>保证线程安全手段：</p> <p>Java并发安全可以从两大类概括，</p> <p>1）不需要共享数据的场景</p> <p>只需要做好线程隔离就行。比如，如果需要传递参数，就使用 <code>ThreadLocal</code>；如果不需要参数传递，就定义为局部变量。</p> <p><span style="color:rgb(122 116 116);">最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式</span></p> <p>2）需要共享数据的场景</p> <ul><li>加锁（阻塞同步/互斥同步）
<ul><li>单机锁（保证同一时刻只有一个线程操作数据）：<code>synchronized</code> 、 <code>ReentrantLock</code></li> <li>分布式锁：<code>Redisson</code> 、 <code>Zookeeper</code></li> <li>读写锁：读不占用锁，写占用锁，在读多写少的并发场景提高性能，例如<code>ReentrantReadWriteLock</code></li></ul></li> <li>不加锁（非阻塞同步）
<ul><li>CAS</li> <li>AtomicInteger</li> <li>ABA</li></ul></li> <li>使用线程安全的容器
<ul><li><code>CurrentHashMap</code></li> <li><code>CopyOnWriteArrayList</code></li></ul></li></ul></details> <details class="custom-block details"><summary>8. 什么是死锁？产生死锁的条件有哪些？</summary> <p>1️⃣ 答：</p> <blockquote><p>死锁（Deadlock）描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。<br>
—— JavaGuide</p></blockquote> <p>死锁指两个以上的运算单元（进程、线程、虚拟线程/协程），都在等待对方释放资源，但没有一方提前释放资源，所造成的阻塞现象就叫做死锁。</p> <p><strong>产生死锁的四个必要条件</strong>：</p> <ul><li><strong>互斥</strong>条件：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li> <li><strong>占有并等待</strong>条件：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li> <li><strong>不可剥夺</strong>条件：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li> <li><strong>环路等待</strong>条件：有一组等待进程 <code>{P0, P1,..., Pn}</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul> <p>⚠️注意：这四个条件是产生死锁的必要条件，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p></details> <details class="custom-block details"><summary>9. 解决死锁的方法有哪些？</summary> <p>解决死锁的方法可以从多个角度去分析，一般的情况下，有 1）<strong>预防</strong>；2）<strong>避免</strong>；3）<strong>检测</strong>；4）<strong>解除</strong> 四种。</p> <p>1）预防 — 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p> <p>2）避免 — 系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生</p> <p>3）检测 — 是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p> <p>4）解除 — 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</p> <p>1️⃣ 答：</p> <p><strong>Java中解决死锁的方法：</strong></p> <ol><li>打破环路等待条件：顺序锁（获取锁的顺序是一致），按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li> <li>打破占有并等待条件：
<ul><li>一次性申请所有的资源</li> <li>使用 <code>ReentrantLock</code> 的 <code>tryLock</code> 方法</li></ul></li> <li>打破不可剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源</li></ol> <p>2️⃣ 细节</p> <p>更详细的内容参考：<a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">操作系统常见面试题总结（上）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details> <details class="custom-block details"><summary>10. 说说 TCP 三次握手？</summary> <p>1️⃣ 答：</p> <p>TCP 三次握手的过程：</p> <ol><li>一开始，客户端A和服务端B都处于 CLOSE 状态。先是服务端B主动监听某个端口，处于 LISTEN 状态</li> <li>客户端A给服务端B发送请求，之后客户端A状态变更为 SYN-SEND，发送的消息：<code>SYN=1, seq=x</code>（<code>x</code> 是客户端A随机初始化的序号）</li> <li>服务端B接收并响应客户端A，之后服务端B状态变更为 SYN-RCVD，发送的消息： <code>SYN=1, ACK=1, seq=y, ack=x+1</code>（<code>y</code> 是服务端B随机初始化的序号）</li> <li>客户端A接收并响应服务端B（最后一个应答报文），之后客户端A状态变更为 ESTABLISHED，发送的消息： <code>ACK=1, seq=x+1, ack=y+1</code></li> <li>服务端B收到客户端A的应答报文后，状态变更为 ESTABLISHED</li></ol> <p>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端A和服务端B就可以相互发送数据了。</p> <p>注：<code>SYN</code> 和 <code>ACK</code> 是标志位状态，<code>seq</code> 是序列号(32位)，<code>ack</code> 是确认应答号(32位)。</p> <p>如图：</p> <p><img src="/blog/assets/img/image-11.07991830.png" alt="TCP三次握手"></p></details> <details class="custom-block details"><summary>11. 说说 TCP 四次挥手？</summary> <p>1️⃣ 答：</p> <p><strong>双方都可以主动断开连接</strong>，断开连接后主机中的「资源」将被释放。<strong>以客户端主动关闭连接为例</strong>，TCP 四次挥手的过程：</p> <ol><li>一开始，客户端A和服务端B都处于 ESTABLISHED 状态，现在客户端A主动关闭连接</li> <li>客户端A给服务端B发送断开请求，之后客户端A状态变更为 FIN_WAIT_1，发送的消息：<code>FIN=1, seq=u</code>（<code>u</code> 等于客户端A前面已传送过的数据的最后一个字节的序号+1）</li> <li>服务端B接收并响应客户端A（发送ACK应答报文），之后服务端B状态变更为 CLOSE_WAIT，发送的消息： <code>ACK=1, seq=v, ack=u+1</code>（<code>v</code> 等于服务端B前面已传送过的数据的最后一个字节的序号+1）</li> <li>客户端A收到服务端B的ACK应答报文后，状态变更为 FIN_WAIT_2</li></ol> <p>（等待服务端B处理完数据后...）</p> <ol start="5"><li>服务端B给客户端A发送断开请求，之后服务端B状态变更为 LAST_ACK，发送的消息： <code>FIN=1, ACK=1, seq=w, ack=u+1</code>（在CLOSE_WAIT状态可能又发送了一些数据，因此序号变成 <code>w</code>）</li> <li>客户端A接收并响应服务端B（发送ACK应答报文），之后客户端A状态变更为 TIME_WAIT，发送消息： <code>ACK=1, seq=u+1, ack=w+1</code></li> <li>服务端B收到客户端A的应答报文后，状态变更为 CLOSE，至此服务端已经完成连接的关闭</li> <li>客户端A在经过 2MSL(MSL,最长报文段寿命) 时间后，状态变更为 CLOSE，至此客户端也完成连接的关闭。</li></ol> <p>注：<code>FIN</code> 和 <code>ACK</code> 是标志位状态，<code>seq</code> 是序列号(32位)，<code>ack</code> 是确认应答号(32位)。</p> <p>如图：
<img src="/blog/assets/img/image-12.48b12649.png" alt="TCP四次挥手"></p> <p>2️⃣ 扩展问题</p> <ol><li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li></ol> <blockquote><p>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote> <p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p> <p>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p></details> <details class="custom-block details"><summary>12. TCP和UDP的区别</summary> <p>1️⃣ 答：</p> <ol><li>连接
<ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li> <li>UDP 是不需要连接，即刻传输数据。</li></ul></li> <li>服务对象
<ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li> <li>UDP 支持一对一、一对多、多对多的交互通信</li></ul></li> <li>可靠性
<ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li> <li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul></li> <li>拥塞控制、流量控制
<ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li> <li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul></li> <li>首部开销
<ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li> <li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul></li> <li>传输方式
<ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li> <li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul></li> <li>分片不同
<ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li> <li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul></li></ol> <p>2️⃣ 细节</p> <p>TCP 和 UDP 应用场景：</p> <p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p> <ul><li>FTP 文件传输；</li> <li>HTTP / HTTPS；</li></ul> <p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p> <ul><li>包总量较少的通信，如 DNS 、SNMP 等；</li> <li>视频、音频等多媒体通信；</li> <li>广播通信；</li></ul></details> <details class="custom-block details"><summary>13. 如何把 UDP 变成类似于TCP那样可靠的协议？</summary> <p>TCP保证可靠性的机制：腾讯QQ（一面）</p> <p>TCP 可靠性保证机制：</p> <ol><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li> <li><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li> <li><strong>重传机制</strong>：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。</li> <li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>（TCP 利用滑动窗口实现流量控制）。</li> <li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。
<ul><li>接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。</li> <li>网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。</li></ul></li></ol></details> <details class="custom-block details"><summary>14. 说说 HashMap 添加流程？</summary> <p>1️⃣ 答：</p> <p>HashMap 的 <code>put(key, value)</code> 添加方法：</p> <ol><li>计算 <code>key</code> 的 <code>hash</code> 值（通过 <code>hash(key)</code> 计算）：
<ul><li>JDK 1.7：
<ul><li>(1) <code>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</code></li> <li>(2) <code>h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</code></li></ul></li> <li>JDK 1.8：<code>((h = key.hashCode()) ^ (h &gt;&gt;&gt; 16))</code></li></ul></li> <li>定位 <code>key</code> 存储位置 bucket 下标：<code>index = hash &amp; (table.length - 1)</code>；</li> <li>插入操作，分情况：
<ul><li>情况1 bucket 为空桶：<strong>直接插入</strong></li> <li>情况2 bucket 非空桶：快速判断第一个节点是否与插入的 <code>key</code> 相同，<strong>相同则插入</strong>，不同则继续...（JDK 1.8 要先判断是链表还是红黑树，再接着遍历）
<ul><li><code>key</code> 不存在：<strong>将键值存储到链表/红黑树尾部</strong>；（Java7 是插入到链表的最前面）</li> <li><code>key</code> 存在：遍历链表/红黑树比较 key，<strong>如果存在 key，更新 value</strong>；</li></ul></li></ul></li> <li>判断当前 bucket 链表是否需要升级为红黑树：链表长度大于 8 ，并且数组大于 64，则升级为红黑树；</li> <li>扩容判断：<code>++size &gt; threshold</code> 成立，则进行扩容操作；（Java7 是先扩容后插入新值的，Java8 先插值再扩容）</li> <li>将执行结果返回</li></ol></details> <details class="custom-block details"><summary>15. 说说快速排序</summary> <p>快速排序核心思想是选择一个基准元素（通常是第一个元素），将数组中的元素和基准值进行对比，小于基准值的放在基准值左边，大于基准值的放在基准值的右边，这就做分区排序，然后再进行递归。</p> <p>快速排序3大步：</p> <ol><li>找基准值</li> <li>分区排序</li> <li>递归排序</li></ol></details> <details class="custom-block details"><summary>16. 设计模式</summary> <p>常见的设计模式：</p> <ol><li>单例模式：Spring/SpringBoot-Bean</li> <li>工厂模式：线程池使用线程共产创建</li> <li>代理模式：Spring AOP</li> <li>发布-订阅模式：MQ</li> <li>观察者模式：Spring Event</li> <li>策略模式：支付渠道（微信/支付宝/...）</li> <li>责任链模式：拦截器链/过滤器链（参数效验、登录状态效验、权限效验、...）</li> <li>门面模式/适配器模式：我们只操作 <code>slf4j</code> -&gt; <code>slf4j</code> 对接操作 <code>log4j</code>、<code>logback</code>。前者（程序员调用 <code>slf4j</code>）是门面模式，后者是适配器模式</li></ol> <p>参考：</p> <ul><li>https://blog.csdn.net/qq_45196093/article/details/130392953</li></ul></details> <details class="custom-block details"><summary>17. 手撕二叉树的右视图</summary> <p>1️⃣ 答：</p> <p>题目：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreferrer">LeetCode 199.二叉树的右视图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>思路1</strong>：使用层序遍历（广度优先搜索），将每一层最后一个节点加入到列表，并返回</p> <ul><li><strong>Step1</strong>： 初始时，先将根节点加入队列，此时队列里存放了第一层的节点</li> <li><strong>Step2</strong>： 队列里存放着一层的节点，此时队尾存放的就是这一层的最后一个节点，将队尾节点放入列表</li> <li><strong>Step3</strong>： 遍历 Step2 的队列，每次出队，将节点的孩子按“左-右”顺序加入队列</li> <li><strong>Step4</strong>： Step3 遍历完成，返回 Step2 执行。循环往复，直到二叉树的最后一层。最后列表里存放着每一层的最右侧节点，即二叉树的右视图。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 列表</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> que <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Step1</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
                <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Step2</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// Step3</span>
                    <span class="token class-name">TreeNode</span> t <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  <span class="token comment">// Step4</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p><strong>思路2：</strong></p> <ul><li>利用 DFS（深度优先搜索） 特性，在遍历时先进入右节点；</li> <li>进入每一层时，最先进入的肯定是这一层的最右侧的节点</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">// 这里利用 dfs 特性，在下面遍历时先进入右节点；</span>
        <span class="token comment">// 进入每一层时，最先进入的肯定是这一层的最右侧的节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> depth<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></details> <h3 id="海康威视-2024-05-19"><a href="#海康威视-2024-05-19" class="header-anchor">#</a> 海康威视 - 2024.05.19</h3> <details class="custom-block details"><summary>1. ArrayList 和 LinkedList 区别</summary> <ol><li>底层实现不同：ArrayList 底层通过数组实现，LinkedList 底层通过双向链表实现</li> <li>查询时间复杂度：根据下标查询时，ArrayList 查询时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，LinkedList 查询时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li> <li>修改效率不同：ArrayList 修改时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，LinkedList 修改时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li> <li>内存布局不同：ArrayList 内存空间连续，LinkedList 空间不一定连续，且占用更多内存（存储前后指针）。</li> <li>线程安全：ArrayList 和 ArrayList 都不是线程安全的。</li></ol></details> <details class="custom-block details"><summary>2. 说说 Bean 的生命周期</summary> <p>Bean 主要生命周期：</p> <ol><li>实例化：为Bean分配内存空间，从无到有</li> <li>属性赋值：创建了Bean对象后，就会进行属性赋值（使用DI/依赖注入）</li> <li>初始化：
<ul><li>初始化的前置方法</li> <li>执行初始化方法</li> <li>初始化的后置方法</li></ul></li> <li>使用</li> <li>销毁</li></ol> <ul><li>https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#spring-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B</li> <li>https://www.bilibili.com/video/BV1rt4y1u7q5/?p=47</li></ul></details> <details class="custom-block details"><summary>3. 说说 IoC 设计原理/设计思想</summary> <p>IoC（Inversion of Control, 控制反转）是一种设计思想/原则，用于降低代码间的耦合度。
IoC 核心思想是将对象的依赖关系从程序内部转移到外部容器，由外部容器负责对象的实例化、配置和组装。这样做的好处是减少了对象之间的直接依赖，增加了系统的灵活性和可扩展性。</p></details> <details class="custom-block details"><summary>4. 数据库的事务隔离级别</summary> <p>MySQL 事务隔离级别：</p> <ul><li>读未提交：一个事务可以读取到另一个事务尚未提交的数据。</li> <li>读已提交：</li> <li>可重复读：MySQL默认隔离级别。一直跟这个事务启动时看到的数据是一致的</li> <li>串行化：事务来了就排队去执行。</li></ul></details> <details class="custom-block details"><summary>5. 说说 CAS 乐观锁的核心流程</summary> <p>CAS 操作的三个值：</p> <ul><li><code>V</code> : 要修改的变量的内存位置</li> <li><code>A</code> : 预期旧值</li> <li><code>B</code> : 新值</li></ul> <p>执行流程：</p> <ol><li>执行前：记录 <code>V</code> 和 <code>A</code> 值</li> <li>执行时：获取 <code>V</code> 目前的值和 <code>A</code> 值进行对比（Compare），如果相等，则将 <code>B</code> 设置到 <code>V</code> 上；如果不相等，通过自旋进行下一轮的对比并替换。</li></ol> <ul><li>https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html#cas</li></ul></details> <details class="custom-block details"><summary>6. 了解 Kafka 吗？</summary> <p>了解。</p> <p><strong>定义</strong>：Kafka 是一个开源的分布式流处理平台和消息系统。</p> <p><strong>特性</strong>：高性能、可扩展、高可用。支持功能相对比较少，如不支持优先级队列、死信队列、延迟队列、不能推送消息（只能拉取消息）等等。</p> <p><strong>组成</strong>：一个 Kafka 集群 =&gt; 多个 Broker =&gt; 一个 Broker 有多个 Topic =&gt; 一个 Topic 有多个分区 Partition。</p> <p><strong>使用</strong>：Kafka + SpringBoot / SpringCloud</p> <ul><li>添加 Kafka 依赖</li> <li>配置 Kafka 连接信息</li> <li>发送消息：使用 KafkaTemplate 对象提供 <code>send(&quot;topic&quot;, value)</code></li> <li>接收消息：<code>@KafkaListener(id=&quot;xxx&quot;, topics=&quot;topic&quot;)</code></li></ul></details> <details class="custom-block details"><summary>7. 双亲委派是解决了什么问题？</summary> <p>解决问题有以下几个：</p> <ul><li>避免类的重复加载</li> <li>避免了类冲突</li> <li>提升了类的安全性：由上层类固定加载</li></ul></details> <details class="custom-block details"><summary>8. 业务流程编排用了什么开源框架？</summary> <p>问题：开源的工作流程引擎有哪些？</p> <p>开源的工作流程引擎：</p> <ol><li>Activiti</li> <li>Flowable</li></ol></details> <details class="custom-block details"><summary>9. 业务灵活多变通常会使用哪种设计模式？</summary> <p>策略模式。</p> <p>策略模式比较灵活，定义一系列算法，将每一个算法独立封装，并且让它们可以相互替换。通过策略模式可以在运行时，...</p></details> <details class="custom-block details"><summary>10. 假如在实际工作中，有一个用户想突然申请一个特殊点的权限，属于特例情况，该怎么设计？</summary> <p>特殊权限的特例操作流程如下：</p> <ol><li>需求和风险评估 → 必要时要向上报备和申请</li> <li>创建一个临时角色，赋值动态权限</li> <li>对该角色/用户进行日志记录和实时监控</li> <li>使用完成后，及时回收角色及其权限</li></ol></details> <details class="custom-block details"><summary>11. 为什么要用 Shiro 框架？</summary> <p>Shiro 使用简单、操作灵活、不依赖某一个具体框架、功能相对全面。</p></details> <details class="custom-block details"><summary>12. Shiro 中的三大核心组件是怎样协同工作的？</summary> <p>Shiro 三大核心组件：</p> <ol><li><strong>Subject</strong>: 代表当前请求的“用户”</li> <li><strong>SecurityManager</strong>: 负责内部组件管理和协调</li> <li><strong>Realm</strong>: 数据源，负责处理身份认证和授权数据。</li></ol> <p>协同流程：</p> <ol><li>用户名和密码封装成用户对象，由 Subject 交给 SecurityManager</li> <li>SecurityManager 将认证请求委托给已配置 Realm 进行处理</li> <li>Realm 将结果返回给 SecurityManager 和 Subject</li></ol></details> <details class="custom-block details"><summary>13. 在进行读取 Excel 表数据读取并插入的时候，有没有遇到什么难题？</summary> <p>小问题有以下几个：</p> <ol><li>Excel 不规范使用时，数据类型转换出错问题</li> <li>性能问题：
<ul><li>读取性能问题：数据量太大 → 数据分批读取、使用并发编程分段处理</li> <li>写入性能问题：使用零拷贝技术 + 异步写入 + 并发编程 + 数据分批处理</li></ul></li> <li>数据映射问题：excel 列名和数据库表中的列名不同的问题</li> <li>其他异常问题：通过合理的记录异常日志、监控系统观测发现和解决问题</li></ol></details> <details class="custom-block details"><summary>14. 使用线程池时，怎么保证每个线程速度的均衡？</summary> <p>速度均衡问题解决方案：</p> <ol><li><strong>设置合理任务粒度</strong>：任务力度不能太粗，任务不均匀导致执行速度不均衡</li> <li><strong>设置合理的线程数量</strong>：线程数太多会造成过度竞争，从而导致性能问题</li> <li><strong>线程执行任务状态的监控</strong>：及时发现任务异常和阻塞的情况，保证正常和线程均衡的执行效率</li></ol></details> <details class="custom-block details"><summary>15. 怎么防止线程池中某个线程异常崩溃？</summary> <p>防止线程池中某个线程异常崩溃：</p> <ol><li>给线程池添加任务时使用 submit 方法，而不是 execute 方法。因为 execute 遇到异常之后会销毁线程、创建新的线程加入到线程池中。</li> <li>使用线程池的监控工具（如 Hippo4j）监控线程池的运行，及时发现、定位、分析、处理问题</li></ol> <ul><li><a href="https://juejin.cn/post/7350917259718574107?searchId=202405192203122F6A0B16DF32FCFE2838" target="_blank" rel="noopener noreferrer">掘金《&quot;线程池中线程异常后：销毁还是复用？&quot;》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></details> <details class="custom-block details"><summary>16. 怎么防止线程池中某个任务阻塞？</summary> <p>防止线程池中某个任务阻塞：</p> <ol><li>对线程池的任务做埋点时间统计</li> <li>给线程设置超时时间，配合 Future 对象 future.get(2, TimeUnit.SECONDS) 设置超时时间</li> <li>定期检查线程池的执行状态</li> <li>使用线程池的监控工具（如 Hippo4j）监控线程池的运行，及时发现、定位、分析、处理问题</li></ol></details></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java/jvm/java_jvm_struct.html" class="prev">
        JVM 内存结构
      </a></span> <span class="next"><a href="/blog/java/java_heima_mianshi.html">
        Java面试总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.5cf145b8.js" defer></script><script src="/blog/assets/js/2.a59f6ee1.js" defer></script><script src="/blog/assets/js/3.1fcfa166.js" defer></script>
  </body>
</html>
